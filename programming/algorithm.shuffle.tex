\chapter{洗牌算法}

\section{Fisher–Yates shuffle}
\subsection{original method}
\begin{enumerate}
\item 按顺序写下1到N；
\item 取得一个随机数K，范围是1到还没有提出的数字的个数；
\item 从小往大，提取出第K个值，删除他，然后在其他位置写下这个数；
\item 重复第2步，直到所有的数字都提取完毕；
\item 在第3步按顺序写下来的数就是原始数据的一个随机排序。
\end{enumerate}

\begin{tabular}{|c|c|l|l|}
	\hline
	范围 & 随机数 & 草稿 & 结果\\
	\hline
	 & &1,2,3,4,5,6,7,8& \\
	\hline
	1-8 & 3 & 1,2,\sout{3},4,5,6,7,8 & 3\\
	\hline
	1-7 & 4 & 1,2,\sout{3},4,\sout{5},6,7,8 & 3,5\\
	\hline
	1-6 & 5 & 1,2,\sout{3},4,\sout{5},6,\sout{7},8 & 3,5,7\\
	\hline
	1-5 & 3 & 1,2,\sout{3},\sout{4},\sout{5},6,\sout{7},8 & 3,5,7,4\\
	\hline
	1-4 & 4 & 1,2,\sout{3},\sout{4},\sout{5},6,\sout{7},\sout{8} & 3,5,7,4,8\\
	\hline
	1-3 & 1 & \sout{1},2,\sout{3},\sout{4},\sout{5},6,\sout{7},\sout{8} & 3,5,7,4,8,1\\
	\hline
	1-2 & 2 & \sout{1},2,\sout{3},\sout{4},\sout{5},\sout{6},\sout{7},\sout{8} & 3,5,7,4,8,1,6\\
	\hline
	1-1 & 1 & \sout{1},\sout{2},\sout{3},\sout{4},\sout{5},\sout{6},\sout{7},\sout{8} & 3,5,7,4,8,1,6,2\\
	\hline
\end{tabular}
\paragraph{具体实现} C\#实现
\begin{CSharp}[Origin Method]
        public static void OriginMethod(int[] origin, int seed)
        {
            Random rnd = new Random(seed);
            for (int i = origin.Length, j; i > 0; i--)
            {
                int roll = rnd.Next(i);
                int tmp = origin[roll];
                for (j = roll; j < i; j++)
                {
                    origin[j] = origin[j + 1];
                }
                origin[j] = tmp;
            }
        }
\end{CSharp}

\subsection{The modern algorithm}

\begin{CSharp}[Modern Method]
        public static void ModernMethodR(int[] origin, int seed)
        {
            Random rnd = new Random(seed);
            for(int i = origin.Length - 1; i > 0; i--)
            {
                int roll = rnd.Next(i + 1);
                Swap(ref origin[i], ref origin[roll]);
            }
        }

        public static void ModernMethodL(int[] origin, int seed)
        {
            Random rnd = new Random(seed);
            for(int i = 0; i < origin.Length - 1; i++)
            {
                int roll = rnd.Next(i, origin.Length);
                Swap(ref origin[i], ref origin[roll]);
            }
        }


        private static void Swap(ref int x, ref int y)
        {
            int tmp = x;
            x = y;
            y = x;
        }
\end{CSharp}

\subsection{The "Inside-out" algorithm}

\begin{CSharp}[Inside-out]
        public static int[] InsideOut(int[] origin, int seed)
        {
            Random rnd = new Random(seed);

            int[] result = new int[origin.Length];
            for(int i = 0; i < origin.Length; i++)
            {
                int roll = rnd.Next(i + 1);
                if (roll != i)
                {
                    result[i] = result[roll];
                }
                result[roll] = origin[i];
            }

            return result;
        }
\end{CSharp}        