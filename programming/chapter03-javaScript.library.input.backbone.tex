\section{Backbone.js}

\subsection{加载}
        
\begin{JavaScript}
(function(root, factory) {

  // Set up Backbone appropriately for the environment. Start with AMD.
  if (typeof define === 'function' && define.amd) {
    define(['underscore', 'jquery', 'exports'], function(_, $, exports) {
      // Export global even in AMD case in case this script is loaded with
      // others that may still expect a global Backbone.
      root.Backbone = factory(root, exports, _, $);
    });

  // Next for Node.js or CommonJS. jQuery may not be needed as a module.
  } else if (typeof exports !== 'undefined') {
    var _ = require('underscore');
    factory(root, exports, _);

  // Finally, as a browser global.
  } else {
    root.Backbone = factory(root, {}, root._, (root.jQuery || root.Zepto || root.ender || root.$));
  }

}(this, function(root, Backbone, _, $) {
    ...
}));
\end{JavaScript}
在这段代码中，给匿名函数传入两个参数，root就是全局对象。传入的是this，js规范中，对于匿名函数的来说this是undefined,所以直接引用了global object。

定义的匿名函数是用来在各种不同的环境下加载Backbone. 
\begin{itemize}
\item 第一个分支，通过define和define.amd属性来判断，在AMD环境下（如requireJS）,这个时候，任然在root上面定义Backbone全局变量。

这里requireJS也是使用CommonJS规范的格式，exports是要导出的module。

\item 第二个在Node下，exports也是需要导出的module

\item 第三种情况就是直接在页面引入backbone脚本的方式，定义在global对象上，exports传入的是一个对象。
\end{itemize}

\subsection{构造}

\begin{JavaScript}[factory方法]
(this, function(root, Backbone, _, $) {

  // Initial Setup
  // -------------

  // Save the previous value of the `Backbone` variable, so that it can be
  // restored later on, if `noConflict` is used.
  var previousBackbone = root.Backbone;

  // Create local references to array methods we'll want to use later.
  var array = [];
  var push = array.push;
  var slice = array.slice;
  var splice = array.splice;

  // Current version of the library. Keep in sync with `package.json`.
  Backbone.VERSION = '1.1.2';

  // For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns
  // the `$` variable.
  Backbone.$ = $;

  // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable
  // to its previous owner. Returns a reference to this Backbone object.
  Backbone.noConflict = function() {
    root.Backbone = previousBackbone;
    return this;
  };
  
  // ...
}
\end{JavaScript}

保存原有的Backbone的值，调用noConflict()的时候可以恢复原来的值。

保存一些常用Array的方法到local，这样应该是为了减少调用链的查找吧？？

四个参数，global object和Backbone本身，两个依赖的三方库。underscore和jQuery。

后面的内容包含了Backbone的几个重要模块。Event，Model，Collection和View

\subsection{Event}

\begin{JavaScript}[Event模块]
  // Backbone.Events
  // ---------------

  // A module that can be mixed in to *any object* in order to provide it with
  // custom events. You may bind with `on` or remove with `off` callback
  // functions to an event; `trigger`-ing an event fires all callbacks in
  // succession.
  //
  //     var object = {};
  //     _.extend(object, Backbone.Events);
  //     object.on('expand', function(){ alert('expanded'); });
  //     object.trigger('expand');
  //
  var Events = Backbone.Events = {

	on: ...
	
	once: ...
	
	off: ...
	
	trigger: ...
	
	stopListening: ...
	
	...
  };

\end{JavaScript}

\subsubsection{eventApi}

Event模块有几个很常用的方法，on, once, off, trigger. 他们都使用了一个方法eventApi。这个方法是用来将key-value形式的name和listener分别调用对应API。或者是空格分割的多个name。如果上述两种情况存在，就返回false，如果什么都没有做，则返回true。

\begin{JavaScript}[eventApi]
  // Regular expression used to split event strings.
  var eventSplitter = /\s+/;

  // Implement fancy features of the Events API such as multiple event
  // names `"change blur"` and jQuery-style event maps `{change: action}`
  // in terms of the existing API.
  var eventsApi = function(obj, action, name, rest) {
    if (!name) return true;

    // Handle event maps.
    if (typeof name === 'object') {
      for (var key in name) {
        obj[action].apply(obj, [key, name[key]].concat(rest));
      }
      return false;
    }

    // Handle space separated event names.
    if (eventSplitter.test(name)) {
      var names = name.split(eventSplitter);
      for (var i = 0, l = names.length; i < l; i++) {
        obj[action].apply(obj, [names[i]].concat(rest));
      }
      return false;
    }

    return true;
  };
\end{JavaScript}

这个方法是用来分解名字中的多个事件，将他们对某个api做一系列调用的。参数为obj, action, name, rest
\begin{itemize}
\item obj是要调用api的对象；
\item api的名称
\item name系列的名字的集合

可能是object，那就是名字和listener对。格式为\lstinline${change: action1, blur: action2}$；

可能是字符串，那就是一系列事件名称，用空格隔开，格式为\lstinline$"change blur"$；

\item rest是调用api是其余的参数。
\end{itemize}

对于上面的两个例子。假设action保存的是字符串\lstinline$"addListener"$
\begin{itemize}
\item name是对象时。假设rest是\lstinline$[true]$
\begin{JavaScript}
obj.addListener("change", action1, true);
obj.addListener("blur", action2, true);
return false;
\end{JavaScript}
\item name是字符串的时候，这个时候rest就必须包含一个公用的回调函数，假设是\lstinline$[action, true]$
\begin{JavaScript}
obj.addListener("change", action, true);
obj.addListener("blur", action, true);
return false;
\end{JavaScript}
\end{itemize}

方法的返回值是用来告诉调用函数这个方法时候做了分解为一系列调用的工作，比如如果名字就是单独的一个change，那么就会直接返回true，这个时候调用他的方法就通过返回值来知道是对单个值在做处理，需要自己来完成实际的工作。

\subsubsection{on}
\begin{JavaScript}
    // Bind an event to a `callback` function. Passing `"all"` will bind
    // the callback to all events fired.
    on: function(name, callback, context) {
      if (!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;
      this._events || (this._events = {});
      var events = this._events[name] || (this._events[name] = []);
      events.push({callback: callback, context: context, ctx: context || this});
      return this;
    },
\end{JavaScript}
通过eventApi，将name分割成单个的事件来调用on方法，执行完第2行代码跳出。

当名字时单个的时候，执行第3行及以后的代码代码。

第3行，初始化event列表；

第4行，取得当前注册的事件在事件列表中的值，如果不存在，初始化为一个空数组；

第5行，保存callback，conext和ctx(这个参数的含义不知道为什么，可能前两个只是保存参数，最后一个才是真正使用的。)；

第6行，返回this，这样就可以chain。

\subsubsection{once}

\begin{JavaScript}
    // Bind an event to only be triggered a single time. After the first time
    // the callback is invoked, it will be removed.
    once: function(name, callback, context) {
      if (!eventsApi(this, 'once', name, [callback, context]) || !callback) return this;
      var self = this;
      var once = _.once(function() {
        self.off(name, once);
        callback.apply(this, arguments);
      });
      once._callback = callback;
      return this.on(name, once, context);
    },
\end{JavaScript}

表示只能被调用一次的回调。

通过underscore的生成只能被调用一次的函数。这个只能调用一次的方法会在调用之前先使用off方法remove掉注册的事件，来保证只被调用一次。

\lstinline$once._callback = callback;$这一部分不知道用意为何，是为了保存一个callback的引用吗？

然后最后使用on方法来注册这个一次性的回调。

\subsubsection{off}
\begin{JavaScript}
    // Remove one or many callbacks. If `context` is null, removes all
    // callbacks with that function. If `callback` is null, removes all
    // callbacks for the event. If `name` is null, removes all bound
    // callbacks for all events.
    off: function(name, callback, context) {
      var retain, ev, events, names, i, l, j, k;
      if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;
      if (!name && !callback && !context) {
        this._events = void 0;
        return this;
      }
      names = name ? [name] : _.keys(this._events);
      for (i = 0, l = names.length; i < l; i++) {
        name = names[i];
        if (events = this._events[name]) {
          this._events[name] = retain = [];
          if (callback || context) {
            for (j = 0, k = events.length; j < k; j++) {
              ev = events[j];
              if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||
                  (context && context !== ev.context)) {
                retain.push(ev);
              }
            }
          }
          if (!retain.length) delete this._events[name];
        }
      }

      return this;
    },
\end{JavaScript}

同样的道理第8行开始真正处理单个注册的监听名。

第8 ~ 11行开始，表示不带参数的时候直接删除所有注册的监听。void 0表示undefined，这个是因为void expression就是返回undefind。

第12行，生成一个名字列表，如果带了name参数，列表就只包含name，否则，列表将包含已注册的所有名字。

循环下来，15行先取得已注册的callback的列表，保存到局部变量events中；

第16行，如果存在已注册的callback，先清空列表（如果callback和context都不存在，那么就执行完成了）；

第17行，如果有callback或者context存在。则历遍events中的所有callback。

第20 ~ 21行，如果context存在，但context不一样；或者callback存在，callback不等于callback，也不等于\lstinline$_callback$ 时。就将他保存回去。

第26行，如果剩下的callback个数等于0了，就将这个name的列表删除。


测试一下，如果用不同的名字，不同的callback，相同context来注册时间，然后在使用\lstinline$event.off(undefined, undefined, context)$来删除，应该不同的callback都要被删除掉。


\subsubsection{trigger}
\begin{JavaScript}
    // Trigger one or many events, firing all bound callbacks. Callbacks are
    // passed the same arguments as `trigger` is, apart from the event name
    // (unless you're listening on `"all"`, which will cause your callback to
    // receive the true name of the event as the first argument).
    trigger: function(name) {
      if (!this._events) return this;
      var args = slice.call(arguments, 1);
      if (!eventsApi(this, 'trigger', name, args)) return this;
      var events = this._events[name];
      var allEvents = this._events.all;
      if (events) triggerEvents(events, args);
      if (allEvents) triggerEvents(allEvents, arguments);
      return this;
    },
\end{JavaScript}

\begin{JavaScript}[优化，根据参数来判断怎么执行，哈哈]
  // A difficult-to-believe, but optimized internal dispatch function for
  // triggering events. Tries to keep the usual cases speedy (most internal
  // Backbone events have 3 arguments).
  var triggerEvents = function(events, args) {
    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
    switch (args.length) {
      case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;
      case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;
      case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;
      case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;
      default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args); return;
    }
  };
\end{JavaScript}

没有什么特别的，将参数带上，出发同名以及all的callback。


\subsubsection{listenTo \& listenToOnce}

\begin{JavaScript}
  var listenMethods = {listenTo: 'on', listenToOnce: 'once'};

  // Inversion-of-control versions of `on` and `once`. Tell *this* object to
  // listen to an event in another object ... keeping track of what it's
  // listening to.
  _.each(listenMethods, function(implementation, method) {
    Events[method] = function(obj, name, callback) {
      var listeningTo = this._listeningTo || (this._listeningTo = {});
      var id = obj._listenId || (obj._listenId = _.uniqueId('l'));
      listeningTo[id] = obj;
      if (!callback && typeof name === 'object') callback = this;
      obj[implementation](name, callback, this);
      return this;
    };
  });
\end{JavaScript}

listenTo和listenToOnce是用来向其他对象注册监听。分别调用其他对象的on和once。

第11行，表示如果name是key-value形式的事件+callback，就将this提前成context。

\subsubsection{bind \& unbind}

\begin{JavaScript}
  // Aliases for backwards compatibility.
  Events.bind   = Events.on;
  Events.unbind = Events.off;
\end{JavaScript}


\begin{JavaScript}[Backbone是个全局的event bus]
  // Allow the `Backbone` object to serve as a global event bus, for folks who
  // want global "pubsub" in a convenient place.
  _.extend(Backbone, Events);
\end{JavaScript}

\subsection{Model}
  这里，在第四行，给每个Model定义了一个唯一ID。第九行，将属性通过set方法赋值给model。最后，调用initialize方法，这个方法在定义自己的Model的时候可以重写，其他的行暂时不去管它，因为我现在也不知道作用。
\begin{JavaScript}
  // Backbone.Model
  // --------------

  // Backbone **Models** are the basic data object in the framework --
  // frequently representing a row in a table in a database on your server.
  // A discrete chunk of data and a bunch of useful, related methods for
  // performing computations and transformations on that data.

  // Create a new model with the specified attributes. A client id (`cid`)
  // is automatically generated and assigned for you.
  var Model = Backbone.Model = function(attributes, options) {
    var attrs = attributes || {};
    options || (options = {});
    this.cid = _.uniqueId('c');
    this.attributes = {};
    if (options.collection) this.collection = options.collection;
    if (options.parse) attrs = this.parse(attrs, options) || {};
    attrs = _.defaults({}, attrs, _.result(this, 'defaults'));
    this.set(attrs, options);
    this.changed = {};
    this.initialize.apply(this, arguments);
  };
\end{JavaScript}

  接下来，重点看看set方法。
  \begin{lstlisting}
    // Set a hash of model attributes on the object, firing `"change"`. This is
    // the core primitive operation of a model, updating the data and notifying
    // anyone who needs to know about the change in state. The heart of the beast.
    set: function(key, val, options) {
      var attr, attrs, unset, changes, silent, changing, prev, current;
      if (key == null) return this;

      // Handle both `"key", value` and `{key: value}` -style arguments.
      if (typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }

      options || (options = {});
  \end{lstlisting}
  这一段，是对key,value和{key:value}情况的处理，如果是后一种情况，那么第二个参数val引用的就是实际上的options，所以这个地方需要重新赋值一下，最后如果options是空，就给他一个空对象。

  \begin{lstlisting}
      // Run validation.
      if (!this._validate(attrs, options)) return false;
  \end{lstlisting}

  如果需要验证，进行验证，失败了的话直接跳出方法。下面是这个方法最复杂的逻辑部分了。在下面开始的部分，会将this.\_changing设为true，然后在方法的最后，将this.\_changing设为false。并且在改变值之前，将她赋值为局部变量changing.这么做的原因是设定一个flag，用来表示这是set方法最开始进入的，还是在调用set方法时，因为一些事件啊，什么的，触发的第二次，第三次进入set。因为如果是第一次进入set，就将原来的attributes保存在this.\_previousAttributes中，并且将this.changed清空。用来保存将要发生改变了的attributes的名字。

  \begin{lstlisting}

      // Extract attributes and options.
      unset           = options.unset;
      silent          = options.silent;
      changes         = [];
      changing        = this._changing;
      this._changing  = true;

      if (!changing) {
        this._previousAttributes = _.clone(this.attributes);
        this.changed = {};
      }

  \end{lstlisting}
  下面的代码对于第一次进入，第二次进入set都是相同的逻辑
  \begin{lstlisting}
      current = this.attributes, prev = this._previousAttributes;

  \end{lstlisting}
  这里，局部变量current保存当前this.attributes，局部变量prev保存的是第一次调用set前的attributes的值。
  \begin{lstlisting}
      // Check for changes of `id`.
      if (this.idAttribute in attrs) this.id = attrs[this.idAttribute];
  \end{lstlisting}
  首先改变id的值，这一步目前我还不知道是为啥。留在后面来更行。

  \begin{lstlisting}
      // For each `set` attribute, update or delete the current value.
      for (attr in attrs) {
        val = attrs[attr];
        if (!_.isEqual(current[attr], val)) changes.push(attr);
        if (!_.isEqual(prev[attr], val)) {
          this.changed[attr] = val;
        } else {
          delete this.changed[attr];
        }
        unset ? delete current[attr] : current[attr] = val;
      }
  \end{lstlisting}

  在这里，如果val和当前值比发生变化，就加入到局部变量changes这个数组中，如果和pre比起来发生变化，就加入到this.changed中，相同的话，就将她从this.changed中删除掉。这里有可能是第一次set将值改变了，第二次set又将值改回来了，这个时候就需要从this.changed中删除掉。最后，如果option中带有unset标志，就删除这个值，否则，修改这个值。

  接下来就是属性修改之后的事件的触发了。
 
  \begin{lstlisting}
      // Trigger all relevant attribute changes.
      if (!silent) {
        if (changes.length) this._pending = options;
        for (var i = 0, l = changes.length; i < l; i++) {
          this.trigger('change:' + changes[i], this, current[changes[i]], options);
        }
      }
  \end{lstlisting}
  如果需要触发事件，那么就出发每个值发生改变了属性的对应事件。
  \begin{lstlisting}
      // You might be wondering why there's a `while` loop here. Changes can
      // be recursively nested within `"change"` events.
      if (changing) return this;
  \end{lstlisting}
  到这一步，如果不是第一次调用set,他们的changing都会是true,到此这里为止。

  而如果是第一次调用set，执行下面的代码。来触发change事件，这里之所以用while，是因为在change事件中，可能又会有属性发生变法，需要再次触发change事件。最后充值\_pending和\_changing。
  \begin{lstlisting}
      if (!silent) {
        while (this._pending) {
          options = this._pending;
          this._pending = false;
          this.trigger('change', this, options);
        }
      }
      this._pending = false;
      this._changing = false;
      return this;
    },

  \end{lstlisting}

  接下来的两个方法很好理解，只是对上面的set方法的调用，并设定好unset,value设置为undefined，这里注意的void 0,这个会在另外一个部分来解释为什么void 0的值是undefined，这样做的一个更好的原因是void 0肯定是undefined,但是undefined不是关键字，可以定义一个变量叫做undefined。

  \begin{lstlisting}
    // Remove an attribute from the model, firing `"change"`. `unset` is a noop
    // if the attribute doesn't exist.
    unset: function(attr, options) {
      return this.set(attr, void 0, _.extend({}, options, {unset: true}));
    },

    // Clear all attributes on the model, firing `"change"`.
    clear: function(options) {
      var attrs = {};
      for (var key in this.attributes) attrs[key] = void 0;
      return this.set(attrs, _.extend({}, options, {unset: true}));
    },

  \end{lstlisting}

  接下来是一个很有用的方法，判断那些属性发生变化，这样可判断view的那部分需要更新，那部分数据需要push到sever上。
  如果没有传入参数，那么就直接返回this.changed的一个克隆或者false。

  如果传入了diff，那就返回Model和diff中不同的属性。
  \begin{lstlisting}
    // Return an object containing all the attributes that have changed, or
    // false if there are no changed attributes. Useful for determining what
    // parts of a view need to be updated and/or what attributes need to be
    // persisted to the server. Unset attributes will be set to undefined.
    // You can also pass an attributes object to diff against the model,
    // determining if there *would be* a change.
    changedAttributes: function(diff) {
      if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;
      var val, changed = false;
      var old = this._changing ? this._previousAttributes : this.attributes;
      for (var attr in diff) {
        if (_.isEqual(old[attr], (val = diff[attr]))) continue;
        (changed || (changed = {}))[attr] = val;
      }
      return changed;
    },
  \end{lstlisting}

  接下来，是重要的方法，fetch，save。这两个方法会调用Restful接口。

  首先处理的是key, value和{key: value}的情况。

  \begin{lstlisting}
    // Set a hash of model attributes, and sync the model to the server.
    // If the server returns an attributes hash that differs, the model's
    // state will be `set` again.
    save: function(key, val, options) {
      var attrs, method, xhr, attributes = this.attributes;

      // Handle both `"key", value` and `{key: value}` -style arguments.
      if (key == null || typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }
  \end{lstlisting}

  \begin{lstlisting}
      options = _.extend({validate: true}, options);

      // If we're not waiting and attributes exist, save acts as
      // `set(attr).save(null, opts)` with validation. Otherwise, check if
      // the model will be valid when the attributes, if any, are set.
      if (attrs && !options.wait) {
        if (!this.set(attrs, options)) return false;
      } else {
        if (!this._validate(attrs, options)) return false;
      }

      // Set temporary attributes if `{wait: true}`.
      if (attrs && options.wait) {
        this.attributes = _.extend({}, attributes, attrs);
      }

      // After a successful server-side save, the client is (optionally)
      // updated with the server-side state.
      if (options.parse === void 0) options.parse = true;
      var model = this;
      var success = options.success;
      options.success = function(resp) {
        // Ensure attributes are restored during synchronous saves.
        model.attributes = attributes;
        var serverAttrs = model.parse(resp, options);
        if (options.wait) serverAttrs = _.extend(attrs || {}, serverAttrs);
        if (_.isObject(serverAttrs) && !model.set(serverAttrs, options)) {
          return false;
        }
        if (success) success(model, resp, options);
        model.trigger('sync', model, resp, options);
      };
      wrapError(this, options);

      method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');
      if (method === 'patch') options.attrs = attrs;
      xhr = this.sync(method, this, options);

      // Restore attributes.
      if (attrs && options.wait) this.attributes = attributes;

      return xhr;
    },
  \end{lstlisting}

  \begin{lstlisting}
    // Destroy this model on the server if it was already persisted.
    // Optimistically removes the model from its collection, if it has one.
    // If `wait: true` is passed, waits for the server to respond before removal.
    destroy: function(options) {
      options = options ? _.clone(options) : {};
      var model = this;
      var success = options.success;

      var destroy = function() {
        model.trigger('destroy', model, model.collection, options);
      };

      options.success = function(resp) {
        if (options.wait || model.isNew()) destroy();
        if (success) success(model, resp, options);
        if (!model.isNew()) model.trigger('sync', model, resp, options);
      };

      if (this.isNew()) {
        options.success();
        return false;
      }
      wrapError(this, options);

      var xhr = this.sync('delete', this, options);
      if (!options.wait) destroy();
      return xhr;
    },
  \end{lstlisting}

  下面是Collection的源码。Model表示的是数据库的一行数据，而Collection表示的则是整个表，或者多行的数据。
  \begin{lstlisting} 

  \end{lstlisting}
