   \section{Backbone.js}
        这是一个轻量级的MVP框架.分析一下源码.

        \subsection{加载}
        
        \begin{lstlisting}
(function(root, factory) {

  // Set up Backbone appropriately for the environment. Start with AMD.
  if (typeof define === 'function' && define.amd) {
    define(['underscore', 'jquery', 'exports'], function(_, $, exports) {
      // Export global even in AMD case in case this script is loaded with
      // others that may still expect a global Backbone.
      root.Backbone = factory(root, exports, _, $);
    });

  // Next for Node.js or CommonJS. jQuery may not be needed as a module.
  } else if (typeof exports !== 'undefined') {
    var _ = require('underscore');
    factory(root, exports, _);

  // Finally, as a browser global.
  } else {
    root.Backbone = factory(root, {}, root._, (root.jQuery || root.Zepto || root.ender || root.$));
  }

}(this, function(root, Backbone, _, $) {
    ...
}));
        \end{lstlisting}

    在这段代码中，定义的匿名函数是用来在各种不同的情况下加载加载Backbone. 在支持AMD的情况，在Node.js，在browser中。factory这个函数才是定义Backbone的地方。接着让我们看看factory函数。


    在factory函数的开始，是一些基本的设置，如版本，引用一些常用的方法，解决冲突的noConfilict。



    \begin{lstlisting}
  // Initial Setup
  // -------------

  // Save the previous value of the `Backbone` variable, so that it can be
  // restored later on, if `noConflict` is used.
  var previousBackbone = root.Backbone;

  // Create local references to array methods we'll want to use later.
  var array = [];
  var push = array.push;
  var slice = array.slice;
  var splice = array.splice;

  // Current version of the library. Keep in sync with `package.json`.
  Backbone.VERSION = '1.1.2';

  // For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns
  // the `$` variable.
  Backbone.$ = $;

  // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable
  // to its previous owner. Returns a reference to this Backbone object.
  Backbone.noConflict = function() {
    root.Backbone = previousBackbone;
    return this;
  };
    \end{lstlisting}


    再继续，就是Backbone的几个重要的模块了。Event，Model，Collection和View。

    \subsection{Event}
    Event模块有几个很常用的方法，on, once, off, trigger. 他们都使用了一个方法eventApi。我们先来看这个方法，然后再去理解上面说到的这些方法。这个方法是用来将key-value形式的name和listener分别调用对应API。或者是空格分割的多个name。如果上述两种情况存在，就返回false，如果什么都没有做，则返回true。

    \begin{lstlisting}
  // Implement fancy features of the Events API such as multiple event
  // names `"change blur"` and jQuery-style event maps `{change: action}`
  // in terms of the existing API.
  var eventsApi = function(obj, action, name, rest) {
    if (!name) return true;

    // Handle event maps.
    if (typeof name === 'object') {
      for (var key in name) {
        obj[action].apply(obj, [key, name[key]].concat(rest));
      }
      return false;
    }

    // Handle space separated event names.
    if (eventSplitter.test(name)) {
      var names = name.split(eventSplitter);
      for (var i = 0, l = names.length; i < l; i++) {
        obj[action].apply(obj, [names[i]].concat(rest));
      }
      return false;
    }

    return true;
  };
    \end{lstlisting}

  \subsection{Model}
  这里，在第四行，给每个Model定义了一个唯一ID。第九行，将属性通过set方法赋值给model。最后，调用initialize方法，这个方法在定义自己的Model的时候可以重写，其他的行暂时不去管它，因为我现在也不知道作用。
  \begin{lstlisting}
  var Model = Backbone.Model = function(attributes, options) {
    var attrs = attributes || {};
    options || (options = {});
    this.cid = _.uniqueId('c');
    this.attributes = {};
    if (options.collection) this.collection = options.collection;
    if (options.parse) attrs = this.parse(attrs, options) || {};
    attrs = _.defaults({}, attrs, _.result(this, 'defaults'));
    this.set(attrs, options);
    this.changed = {};
    this.initialize.apply(this, arguments);
  };
  \end{lstlisting}

  接下来，重点看看set方法。
  \begin{lstlisting}
    // Set a hash of model attributes on the object, firing `"change"`. This is
    // the core primitive operation of a model, updating the data and notifying
    // anyone who needs to know about the change in state. The heart of the beast.
    set: function(key, val, options) {
      var attr, attrs, unset, changes, silent, changing, prev, current;
      if (key == null) return this;

      // Handle both `"key", value` and `{key: value}` -style arguments.
      if (typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }

      options || (options = {});
  \end{lstlisting}
  这一段，是对key,value和{key:value}情况的处理，如果是后一种情况，那么第二个参数val引用的就是实际上的options，所以这个地方需要重新赋值一下，最后如果options是空，就给他一个空对象。

  \begin{lstlisting}
      // Run validation.
      if (!this._validate(attrs, options)) return false;
  \end{lstlisting}

  如果需要验证，进行验证，失败了的话直接跳出方法。下面是这个方法最复杂的逻辑部分了。在下面开始的部分，会将this.\_changing设为true，然后在方法的最后，将this.\_changing设为false。并且在改变值之前，将她赋值为局部变量changing.这么做的原因是设定一个flag，用来表示这是set方法最开始进入的，还是在调用set方法时，因为一些事件啊，什么的，触发的第二次，第三次进入set。因为如果是第一次进入set，就将原来的attributes保存在this.\_previousAttributes中，并且将this.changed清空。用来保存将要发生改变了的attributes的名字。

  \begin{lstlisting}

      // Extract attributes and options.
      unset           = options.unset;
      silent          = options.silent;
      changes         = [];
      changing        = this._changing;
      this._changing  = true;

      if (!changing) {
        this._previousAttributes = _.clone(this.attributes);
        this.changed = {};
      }

  \end{lstlisting}
  下面的代码对于第一次进入，第二次进入set都是相同的逻辑
  \begin{lstlisting}
      current = this.attributes, prev = this._previousAttributes;

  \end{lstlisting}
  这里，局部变量current保存当前this.attributes，局部变量prev保存的是第一次调用set前的attributes的值。
  \begin{lstlisting}
      // Check for changes of `id`.
      if (this.idAttribute in attrs) this.id = attrs[this.idAttribute];
  \end{lstlisting}
  首先改变id的值，这一步目前我还不知道是为啥。留在后面来更行。

  \begin{lstlisting}
      // For each `set` attribute, update or delete the current value.
      for (attr in attrs) {
        val = attrs[attr];
        if (!_.isEqual(current[attr], val)) changes.push(attr);
        if (!_.isEqual(prev[attr], val)) {
          this.changed[attr] = val;
        } else {
          delete this.changed[attr];
        }
        unset ? delete current[attr] : current[attr] = val;
      }
  \end{lstlisting}

  在这里，如果val和当前值比发生变化，就加入到局部变量changes这个数组中，如果和pre比起来发生变化，就加入到this.changed中，相同的话，就将她从this.changed中删除掉。这里有可能是第一次set将值改变了，第二次set又将值改回来了，这个时候就需要从this.changed中删除掉。最后，如果option中带有unset标志，就删除这个值，否则，修改这个值。

  接下来就是属性修改之后的事件的触发了。
 
  \begin{lstlisting}
      // Trigger all relevant attribute changes.
      if (!silent) {
        if (changes.length) this._pending = options;
        for (var i = 0, l = changes.length; i < l; i++) {
          this.trigger('change:' + changes[i], this, current[changes[i]], options);
        }
      }
  \end{lstlisting}
  如果需要触发事件，那么就出发每个值发生改变了属性的对应事件。
  \begin{lstlisting}
      // You might be wondering why there's a `while` loop here. Changes can
      // be recursively nested within `"change"` events.
      if (changing) return this;
  \end{lstlisting}
  到这一步，如果不是第一次调用set,他们的changing都会是true,到此这里为止。

  而如果是第一次调用set，执行下面的代码。来触发change事件，这里之所以用while，是因为在change事件中，可能又会有属性发生变法，需要再次触发change事件。最后充值\_pending和\_changing。
  \begin{lstlisting}
      if (!silent) {
        while (this._pending) {
          options = this._pending;
          this._pending = false;
          this.trigger('change', this, options);
        }
      }
      this._pending = false;
      this._changing = false;
      return this;
    },

  \end{lstlisting}

  接下来的两个方法很好理解，只是对上面的set方法的调用，并设定好unset,value设置为undefined，这里注意的void 0,这个会在另外一个部分来解释为什么void 0的值是undefined，这样做的一个更好的原因是void 0肯定是undefined,但是undefined不是关键字，可以定义一个变量叫做undefined。

  \begin{lstlisting}
    // Remove an attribute from the model, firing `"change"`. `unset` is a noop
    // if the attribute doesn't exist.
    unset: function(attr, options) {
      return this.set(attr, void 0, _.extend({}, options, {unset: true}));
    },

    // Clear all attributes on the model, firing `"change"`.
    clear: function(options) {
      var attrs = {};
      for (var key in this.attributes) attrs[key] = void 0;
      return this.set(attrs, _.extend({}, options, {unset: true}));
    },

  \end{lstlisting}

  接下来是一个很有用的方法，判断那些属性发生变化，这样可判断view的那部分需要更新，那部分数据需要push到sever上。
  如果没有传入参数，那么就直接返回this.changed的一个克隆或者false。

  如果传入了diff，那就返回Model和diff中不同的属性。
  \begin{lstlisting}
    // Return an object containing all the attributes that have changed, or
    // false if there are no changed attributes. Useful for determining what
    // parts of a view need to be updated and/or what attributes need to be
    // persisted to the server. Unset attributes will be set to undefined.
    // You can also pass an attributes object to diff against the model,
    // determining if there *would be* a change.
    changedAttributes: function(diff) {
      if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;
      var val, changed = false;
      var old = this._changing ? this._previousAttributes : this.attributes;
      for (var attr in diff) {
        if (_.isEqual(old[attr], (val = diff[attr]))) continue;
        (changed || (changed = {}))[attr] = val;
      }
      return changed;
    },
  \end{lstlisting}

  接下来，是重要的方法，fetch，save。这两个方法会调用Restful接口。

  首先处理的是key, value和{key: value}的情况。

  \begin{lstlisting}
    // Set a hash of model attributes, and sync the model to the server.
    // If the server returns an attributes hash that differs, the model's
    // state will be `set` again.
    save: function(key, val, options) {
      var attrs, method, xhr, attributes = this.attributes;

      // Handle both `"key", value` and `{key: value}` -style arguments.
      if (key == null || typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }
  \end{lstlisting}

  \begin{lstlisting}
      options = _.extend({validate: true}, options);

      // If we're not waiting and attributes exist, save acts as
      // `set(attr).save(null, opts)` with validation. Otherwise, check if
      // the model will be valid when the attributes, if any, are set.
      if (attrs && !options.wait) {
        if (!this.set(attrs, options)) return false;
      } else {
        if (!this._validate(attrs, options)) return false;
      }

      // Set temporary attributes if `{wait: true}`.
      if (attrs && options.wait) {
        this.attributes = _.extend({}, attributes, attrs);
      }

      // After a successful server-side save, the client is (optionally)
      // updated with the server-side state.
      if (options.parse === void 0) options.parse = true;
      var model = this;
      var success = options.success;
      options.success = function(resp) {
        // Ensure attributes are restored during synchronous saves.
        model.attributes = attributes;
        var serverAttrs = model.parse(resp, options);
        if (options.wait) serverAttrs = _.extend(attrs || {}, serverAttrs);
        if (_.isObject(serverAttrs) && !model.set(serverAttrs, options)) {
          return false;
        }
        if (success) success(model, resp, options);
        model.trigger('sync', model, resp, options);
      };
      wrapError(this, options);

      method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');
      if (method === 'patch') options.attrs = attrs;
      xhr = this.sync(method, this, options);

      // Restore attributes.
      if (attrs && options.wait) this.attributes = attributes;

      return xhr;
    },
  \end{lstlisting}

  \begin{lstlisting}
    // Destroy this model on the server if it was already persisted.
    // Optimistically removes the model from its collection, if it has one.
    // If `wait: true` is passed, waits for the server to respond before removal.
    destroy: function(options) {
      options = options ? _.clone(options) : {};
      var model = this;
      var success = options.success;

      var destroy = function() {
        model.trigger('destroy', model, model.collection, options);
      };

      options.success = function(resp) {
        if (options.wait || model.isNew()) destroy();
        if (success) success(model, resp, options);
        if (!model.isNew()) model.trigger('sync', model, resp, options);
      };

      if (this.isNew()) {
        options.success();
        return false;
      }
      wrapError(this, options);

      var xhr = this.sync('delete', this, options);
      if (!options.wait) destroy();
      return xhr;
    },
  \end{lstlisting}

  下面是Collection的源码。Model表示的是数据库的一行数据，而Collection表示的则是整个表，或者多行的数据。
  \begin{lstlisting} 

  \end{lstlisting}
