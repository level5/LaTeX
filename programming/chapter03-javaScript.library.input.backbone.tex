\section{Backbone.js}


\section{例子}

\subsection{加载}
        
\begin{JavaScript}
(function(root, factory) {

  // Set up Backbone appropriately for the environment. Start with AMD.
  if (typeof define === 'function' && define.amd) {
    define(['underscore', 'jquery', 'exports'], function(_, $, exports) {
      // Export global even in AMD case in case this script is loaded with
      // others that may still expect a global Backbone.
      root.Backbone = factory(root, exports, _, $);
    });

  // Next for Node.js or CommonJS. jQuery may not be needed as a module.
  } else if (typeof exports !== 'undefined') {
    var _ = require('underscore');
    factory(root, exports, _);

  // Finally, as a browser global.
  } else {
    root.Backbone = factory(root, {}, root._, (root.jQuery || root.Zepto || root.ender || root.$));
  }

}(this, function(root, Backbone, _, $) {
    ...
}));
\end{JavaScript}
在这段代码中，给匿名函数传入两个参数，root就是全局对象。传入的是this，js规范中，对于匿名函数的来说this是undefined,所以直接引用了global object。

定义的匿名函数是用来在各种不同的环境下加载Backbone. 
\begin{itemize}
\item 第一个分支，通过define和define.amd属性来判断，在AMD环境下（如requireJS）,这个时候，任然在root上面定义Backbone全局变量。

这里requireJS也是使用CommonJS规范的格式，exports是要导出的module。

\item 第二个在Node下，exports也是需要导出的module

\item 第三种情况就是直接在页面引入backbone脚本的方式，定义在global对象上，exports传入的是一个对象。
\end{itemize}

\subsection{构造}

\begin{JavaScript}[factory方法]
(this, function(root, Backbone, _, $) {

  // Initial Setup
  // -------------

  // Save the previous value of the `Backbone` variable, so that it can be
  // restored later on, if `noConflict` is used.
  var previousBackbone = root.Backbone;

  // Create local references to array methods we'll want to use later.
  var array = [];
  var push = array.push;
  var slice = array.slice;
  var splice = array.splice;

  // Current version of the library. Keep in sync with `package.json`.
  Backbone.VERSION = '1.1.2';

  // For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns
  // the `$` variable.
  Backbone.$ = $;

  // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable
  // to its previous owner. Returns a reference to this Backbone object.
  Backbone.noConflict = function() {
    root.Backbone = previousBackbone;
    return this;
  };
  
  // ...
}
\end{JavaScript}

保存原有的Backbone的值，调用noConflict()的时候可以恢复原来的值。

保存一些常用Array的方法到local，这样应该是为了减少调用链的查找吧？？应该还有就是压缩代码的时候可以

四个参数，global object和Backbone本身，两个依赖的三方库。underscore和jQuery。

后面的内容包含了Backbone的几个重要模块。Event，Model，Collection和View

\subsection{Event}

\begin{JavaScript}[Event模块]
  // Backbone.Events
  // ---------------

  // A module that can be mixed in to *any object* in order to provide it with
  // custom events. You may bind with `on` or remove with `off` callback
  // functions to an event; `trigger`-ing an event fires all callbacks in
  // succession.
  //
  //     var object = {};
  //     _.extend(object, Backbone.Events);
  //     object.on('expand', function(){ alert('expanded'); });
  //     object.trigger('expand');
  //
  var Events = Backbone.Events = {

	on: ...
	
	once: ...
	
	off: ...
	
	trigger: ...
	
	stopListening: ...
	
	...
  };

\end{JavaScript}

\subsubsection{eventApi}

Event模块有几个很常用的方法，on, once, off, trigger. 他们都使用了一个方法eventApi。这个方法是用来将key-value形式的name和listener分别调用对应API。或者是空格分割的多个name。如果上述两种情况存在，就返回false，如果什么都没有做，则返回true。

\begin{JavaScript}[eventApi]
  // Regular expression used to split event strings.
  var eventSplitter = /\s+/;

  // Implement fancy features of the Events API such as multiple event
  // names `"change blur"` and jQuery-style event maps `{change: action}`
  // in terms of the existing API.
  var eventsApi = function(obj, action, name, rest) {
    if (!name) return true;

    // Handle event maps.
    if (typeof name === 'object') {
      for (var key in name) {
        obj[action].apply(obj, [key, name[key]].concat(rest));
      }
      return false;
    }

    // Handle space separated event names.
    if (eventSplitter.test(name)) {
      var names = name.split(eventSplitter);
      for (var i = 0, l = names.length; i < l; i++) {
        obj[action].apply(obj, [names[i]].concat(rest));
      }
      return false;
    }

    return true;
  };
\end{JavaScript}

这个方法是用来分解名字中的多个事件，将他们对某个api做一系列调用的。参数为obj, action, name, rest
\begin{itemize}
\item obj是要调用api的对象；
\item api的名称
\item name系列的名字的集合

可能是object，那就是名字和listener对。格式为\lstinline${change: action1, blur: action2}$；

可能是字符串，那就是一系列事件名称，用空格隔开，格式为\lstinline$"change blur"$；

\item rest是调用api是其余的参数。
\end{itemize}

对于上面的两个例子。假设action保存的是字符串\lstinline$"addListener"$
\begin{itemize}
\item name是对象时。假设rest是\lstinline$[true]$
\begin{JavaScript}
obj.addListener("change", action1, true);
obj.addListener("blur", action2, true);
return false;
\end{JavaScript}
\item name是字符串的时候，这个时候rest就必须包含一个公用的回调函数，假设是\lstinline$[action, true]$
\begin{JavaScript}
obj.addListener("change", action, true);
obj.addListener("blur", action, true);
return false;
\end{JavaScript}
\end{itemize}

方法的返回值是用来告诉调用函数这个方法时候做了分解为一系列调用的工作，比如如果名字就是单独的一个change，那么就会直接返回true，这个时候调用他的方法就通过返回值来知道是对单个值在做处理，需要自己来完成实际的工作。

\subsubsection{on}
\begin{JavaScript}
    // Bind an event to a `callback` function. Passing `"all"` will bind
    // the callback to all events fired.
    on: function(name, callback, context) {
      if (!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;
      this._events || (this._events = {});
      var events = this._events[name] || (this._events[name] = []);
      events.push({callback: callback, context: context, ctx: context || this});
      return this;
    },
\end{JavaScript}
通过eventApi，将name分割成单个的事件来调用on方法，执行完第2行代码跳出。

当名字时单个的时候，执行第3行及以后的代码代码。

第3行，初始化event列表；

第4行，取得当前注册的事件在事件列表中的值，如果不存在，初始化为一个空数组；

第5行，保存callback，conext和ctx(这个参数的含义不知道为什么，可能前两个只是保存参数，最后一个才是真正使用的。)；

第6行，返回this，这样就可以chain。

\subsubsection{once}

\begin{JavaScript}
    // Bind an event to only be triggered a single time. After the first time
    // the callback is invoked, it will be removed.
    once: function(name, callback, context) {
      if (!eventsApi(this, 'once', name, [callback, context]) || !callback) return this;
      var self = this;
      var once = _.once(function() {
        self.off(name, once);
        callback.apply(this, arguments);
      });
      once._callback = callback;
      return this.on(name, once, context);
    },
\end{JavaScript}

表示只能被调用一次的回调。

通过underscore的生成只能被调用一次的函数。这个只能调用一次的方法会在调用之前先使用off方法remove掉注册的事件，来保证只被调用一次。

\lstinline$once._callback = callback;$这一部分不知道用意为何，是为了保存一个callback的引用吗？

然后最后使用on方法来注册这个一次性的回调。

\subsubsection{off}
\begin{JavaScript}
    // Remove one or many callbacks. If `context` is null, removes all
    // callbacks with that function. If `callback` is null, removes all
    // callbacks for the event. If `name` is null, removes all bound
    // callbacks for all events.
    off: function(name, callback, context) {
      var retain, ev, events, names, i, l, j, k;
      if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;
      if (!name && !callback && !context) {
        this._events = void 0;
        return this;
      }
      names = name ? [name] : _.keys(this._events);
      for (i = 0, l = names.length; i < l; i++) {
        name = names[i];
        if (events = this._events[name]) {
          this._events[name] = retain = [];
          if (callback || context) {
            for (j = 0, k = events.length; j < k; j++) {
              ev = events[j];
              if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||
                  (context && context !== ev.context)) {
                retain.push(ev);
              }
            }
          }
          if (!retain.length) delete this._events[name];
        }
      }

      return this;
    },
\end{JavaScript}

同样的道理第8行开始真正处理单个注册的监听名。

第8 ~ 11行开始，表示不带参数的时候直接删除所有注册的监听。void 0表示undefined，这个是因为void expression就是返回undefind。

第12行，生成一个名字列表，如果带了name参数，列表就只包含name，否则，列表将包含已注册的所有名字。

循环下来，15行先取得已注册的callback的列表，保存到局部变量events中；

第16行，如果存在已注册的callback，先清空列表（如果callback和context都不存在，那么就执行完成了）；

第17行，如果有callback或者context存在。则历遍events中的所有callback。

第20 ~ 21行，如果context存在，但context不一样；或者callback存在，callback不等于callback，也不等于\lstinline$_callback$ 时。就将他保存回去。

第26行，如果剩下的callback个数等于0了，就将这个name的列表删除。


测试一下，如果用不同的名字，不同的callback，相同context来注册时间，然后在使用\lstinline$event.off(undefined, undefined, context)$来删除，应该不同的callback都要被删除掉。


\subsubsection{trigger}
\begin{JavaScript}
    // Trigger one or many events, firing all bound callbacks. Callbacks are
    // passed the same arguments as `trigger` is, apart from the event name
    // (unless you're listening on `"all"`, which will cause your callback to
    // receive the true name of the event as the first argument).
    trigger: function(name) {
      if (!this._events) return this;
      var args = slice.call(arguments, 1);
      if (!eventsApi(this, 'trigger', name, args)) return this;
      var events = this._events[name];
      var allEvents = this._events.all;
      if (events) triggerEvents(events, args);
      if (allEvents) triggerEvents(allEvents, arguments);
      return this;
    },
\end{JavaScript}

\begin{JavaScript}[优化，根据参数来判断怎么执行，哈哈]
  // A difficult-to-believe, but optimized internal dispatch function for
  // triggering events. Tries to keep the usual cases speedy (most internal
  // Backbone events have 3 arguments).
  var triggerEvents = function(events, args) {
    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
    switch (args.length) {
      case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;
      case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;
      case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;
      case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;
      default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args); return;
    }
  };
\end{JavaScript}

没有什么特别的，将参数带上，出发同名以及all的callback。


\subsubsection{listenTo \& listenToOnce}

\begin{JavaScript}
  var listenMethods = {listenTo: 'on', listenToOnce: 'once'};

  // Inversion-of-control versions of `on` and `once`. Tell *this* object to
  // listen to an event in another object ... keeping track of what it's
  // listening to.
  _.each(listenMethods, function(implementation, method) {
    Events[method] = function(obj, name, callback) {
      var listeningTo = this._listeningTo || (this._listeningTo = {});
      var id = obj._listenId || (obj._listenId = _.uniqueId('l'));
      listeningTo[id] = obj;
      if (!callback && typeof name === 'object') callback = this;
      obj[implementation](name, callback, this);
      return this;
    };
  });
\end{JavaScript}

listenTo和listenToOnce是用来向其他对象注册监听。分别调用其他对象的on和once。

第11行，表示如果name是key-value形式的事件+callback，就将this提前成context。

\subsubsection{bind \& unbind}

\begin{JavaScript}
  // Aliases for backwards compatibility.
  Events.bind   = Events.on;
  Events.unbind = Events.off;
\end{JavaScript}


\begin{JavaScript}[Backbone是个全局的event bus]
  // Allow the `Backbone` object to serve as a global event bus, for folks who
  // want global "pubsub" in a convenient place.
  _.extend(Backbone, Events);
\end{JavaScript}

\subsection{Model}

\begin{JavaScript}
  // Backbone.Model
  // --------------

  // Backbone **Models** are the basic data object in the framework --
  // frequently representing a row in a table in a database on your server.
  // A discrete chunk of data and a bunch of useful, related methods for
  // performing computations and transformations on that data.

  // Create a new model with the specified attributes. A client id (`cid`)
  // is automatically generated and assigned for you.
  var Model = Backbone.Model = function(attributes, options) {
    var attrs = attributes || {};
    options || (options = {});
    this.cid = _.uniqueId('c');
    this.attributes = {};
    if (options.collection) this.collection = options.collection;
    if (options.parse) attrs = this.parse(attrs, options) || {};
    attrs = _.defaults({}, attrs, _.result(this, 'defaults'));
    this.set(attrs, options);
    this.changed = {};
    this.initialize.apply(this, arguments);
  };
\end{JavaScript}

前面大部分就是设定this的properties，主要操作集中在最后部分。

\begin{JavaScript}
    if (options.parse) attrs = this.parse(attrs, options) || {};
    attrs = _.defaults({}, attrs, _.result(this, 'defaults'));
    this.set(attrs, options);
    this.changed = {};
    this.initialize.apply(this, arguments);
\end{JavaScript}

underscore的defaults方法就是在第一个object上定义后面的参数的对象包含的properties，其值为第一次出现的值。

underscore的results方法是，如果第一个参数的property name为第二个参数的值是function的话，返回这个方法的值（第一个参数作为context），否则，直接返回这个值。

那么，第1行就是如果需要parse attrs，那么就parse一下；

然后第2行合并一下传入的attrs和原来就存在的值（看上去是这样，需要看看defaults到底是function还是保存的值。）

第3行，使用set来设定attrs（key step）；

第4行，初始化changed.

第5行，调用initialize方法(默认实现是一个空function，应该是为了提供一个类似于js的构造函数，或者objective-c的init方法的地方)。



\subsubsection{set}

\begin{JavaScript}
  _.extend(Model.prototype, Events, {

    // A hash of attributes whose current and previous value differ.
    changed: null,

    // The value returned during the last failed validation.
    validationError: null,

    // The default name for the JSON `id` attribute is `"id"`. MongoDB and
    // CouchDB users may want to set this to `"_id"`.
    idAttribute: 'id',

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},
	
    ...

    // Set a hash of model attributes on the object, firing `"change"`. This is
    // the core primitive operation of a model, updating the data and notifying
    // anyone who needs to know about the change in state. The heart of the beast.
    set: function(key, val, options) {
      var attr, attrs, unset, changes, silent, changing, prev, current;
      if (key == null) return this;

      // Handle both `"key", value` and `{key: value}` -style arguments.
      if (typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }

      options || (options = {});

      // Run validation.
      if (!this._validate(attrs, options)) return false;

      // Extract attributes and options.
      unset           = options.unset;
      silent          = options.silent;
      changes         = [];
      changing        = this._changing;
      this._changing  = true;

      if (!changing) {
        this._previousAttributes = _.clone(this.attributes);
        this.changed = {};
      }
      current = this.attributes, prev = this._previousAttributes;

      // Check for changes of `id`.
      if (this.idAttribute in attrs) this.id = attrs[this.idAttribute];

      // For each `set` attribute, update or delete the current value.
      for (attr in attrs) {
        val = attrs[attr];
        if (!_.isEqual(current[attr], val)) changes.push(attr);
        if (!_.isEqual(prev[attr], val)) {
          this.changed[attr] = val;
        } else {
          delete this.changed[attr];
        }
        unset ? delete current[attr] : current[attr] = val;
      }

      // Trigger all relevant attribute changes.
      if (!silent) {
        if (changes.length) this._pending = options;
        for (var i = 0, l = changes.length; i < l; i++) {
          this.trigger('change:' + changes[i], this, current[changes[i]], options);
        }
      }

      // You might be wondering why there's a `while` loop here. Changes can
      // be recursively nested within `"change"` events.
      if (changing) return this;
      if (!silent) {
        while (this._pending) {
          options = this._pending;
          this._pending = false;
          this.trigger('change', this, options);
        }
      }
      this._pending = false;
      this._changing = false;
      return this;
    },
	
	...

  });
\end{JavaScript}

第27 ~ 34行，是对key,value和{key:value}情况的处理，如果是后一种情况（即key是一个对象），那么第二个参数val引用的就是实际上的options，所以这个地方需要重新赋值一下，最后如果options是空，就给他一个空对象，避免以后每次都要对options做非空判断。


第37行，如果需要验证，进行验证，失败了的话直接跳出方法。这里会返回false，其他情况下都是返回this（如果自动转换成boolean，那就是true），这个在后面可以用来判断是不是验证失败退出了。

第44行，会将\lstinline$this._changing$设为true，然后在方法的最后，将\lstinline$this._changing$设为false。并且在改变值之前，将她赋值为局部变量changing（第43行）.这么做的原因是设定一个flag，用来表示这是set方法最开始进入的，还是在调用set方法时，因为一些事件啊，什么的，触发的第二次，第三次进入set。因为如果是第一次进入set(第46 ~ 49行)，就将原来的attributes保存在\lstinline$this._previousAttributes$ 中，并且将\lstinline$this.changed$清空。用来保存将要发生改变了的attributes的名字。

第50行，第一次进入，第二次进入set都是相同的逻辑，这里，局部变量current保存当前this.attributes，局部变量prev保存的是第一次调用set前的attributes的值。

第53行，首先改变id的值，这一步（为什么要先做id的更新）目前我还不知道是为啥。留在后面来跟新。


第56 ~ 64行，在这里，如果val和当前值比发生变化，就加入到局部变量changes这个数组中，如果和pre比起来发生变化，就加入到this.changed中，相同的话，就将她从this.changed中删除掉。这里有可能是第一次set将值改变了，第二次set又将值改回来了，这个时候就需要从this.changed中删除掉。最后，如果option中带有unset标志，就删除这个值，否则，修改这个值，这里看来，如果是要删除，应该讲value的值设定为undefined，因为如果不是这样，可能不能够正确的触发事件（这里可以写代码测试一下。）。



第68行，就是属性修改之后的事件的触发了。 如果需要触发事件，那么就出发每个值发生改变了属性(change:key)的对应事件。第69行，将options保存到\lstinline$this._pending$(和第77行有关).

第77行，表示现在如果不是第一次调用set，而是在set中触发的事件来触发的set方法的调用，那么程序执行到此为止为止，现在不触发change事件。那么，上面的\lstinline$this._pending$就是保存的最后一次的options了。

这里是不是发送change事件是根据silent和\lstinline$this._pending$ 这个变量来决定，不是通过是否有属性发生变化来决定，所以如果调用了set方法，如果有属性发生了变化，即使在属性change事件中又变回来了，还是会发送change事件的。

而第78行中使用了while，是因为change事件也可能触发set调用，这个时候，change事件内调用的set会执行到77行，这个时候\lstinline$this._pending$又会重新被赋值。需要再次调用change事件。


也就是说如果在属性变化事件(change:key)中触发了set，前面一次的change会被后面的一次冲掉。带的options会是后面那一次的options（这个地方可以写段测试一下）。而在change事件中触发set，后面还需要继续再触发一次change事件。

\subsubsection{unset \& clear}

\begin{JavaScript}
    // Remove an attribute from the model, firing `"change"`. `unset` is a noop
    // if the attribute doesn't exist.
    unset: function(attr, options) {
      return this.set(attr, void 0, _.extend({}, options, {unset: true}));
    },

    // Clear all attributes on the model, firing `"change"`.
    clear: function(options) {
      var attrs = {};
      for (var key in this.attributes) attrs[key] = void 0;
      return this.set(attrs, _.extend({}, options, {unset: true}));
    },
\end{JavaScript}

这两个方法很好理解，只是对上面的set方法的调用，并设定好unset,value设置为undefined，这里注意的void 0,这个会在另外一个部分来解释为什么void 0的值是undefined，这样做的一个更好的原因是void 0肯定是undefined,但是undefined不是关键字，可以定义一个变量叫做undefined。

这个时候如果原来的值是{key： 1}, 我调用unset({key:1})和调用unset({key:2})得到的属性事件是不一样的吧？？？测试一下。

\subsubsection{hasChanged}

\begin{JavaScript}
    // Determine if the model has changed since the last `"change"` event.
    // If you specify an attribute name, determine if that attribute has changed.
    hasChanged: function(attr) {
      if (attr == null) return !_.isEmpty(this.changed);
      return _.has(this.changed, attr);
    },
\end{JavaScript}

没啥特别的，就是判断\lstinline$this.changed$是否有值，这个property在每次set的时候都会清空，所以这个是相对的。

这么说来，如果第一次我调用set修改了值，导致change事件触发了，然后我在调用一次set，这个时候没有属性发生变化，但是changed应该也被清除了。到时这个时候的haschanged这个值就不同了吧，所以应该拿最后一次change event来做为其实貌似不太合理。（测试一下测试一下）。

\subsubsection{changedAttributes}

\begin{JavaScript}
    // Return an object containing all the attributes that have changed, or
    // false if there are no changed attributes. Useful for determining what
    // parts of a view need to be updated and/or what attributes need to be
    // persisted to the server. Unset attributes will be set to undefined.
    // You can also pass an attributes object to diff against the model,
    // determining if there *would be* a change.
    changedAttributes: function(diff) {
      if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;
      var val, changed = false;
      var old = this._changing ? this._previousAttributes : this.attributes;
      for (var attr in diff) {
        if (_.isEqual(old[attr], (val = diff[attr]))) continue;
        (changed || (changed = {}))[attr] = val;
      }
      return changed;
    },
\end{JavaScript}

如果不带参数，就直接返回changed property的一个拷贝，或者返回false告诉没有变化；

如果带有参数，就是返回现在的model和传入的参数之间有差别的地方。

第10行，取得最初的attributes的值，如果是在set中间调用的就取\lstinline$this._previousAttributes$，否则直接取\lstinline$this.attributes$

\begin{JavaScript}[这个js中第一个计算结果如果为false，就直接返回第二个参数，所以返回的是changed]
(changed || (changed = {}))[attr] = val;
\end{JavaScript}

\subsubsection{previous \& previousAttributes}

\begin{JavaScript}
    // Get the previous value of an attribute, recorded at the time the last
    // `"change"` event was fired.
    previous: function(attr) {
      if (attr == null || !this._previousAttributes) return null;
      return this._previousAttributes[attr];
    },

    // Get all of the attributes of the model at the time of the previous
    // `"change"` event.
    previousAttributes: function() {
      return _.clone(this._previousAttributes);
    },
\end{JavaScript}

文档上说是during event的时候使用，应该在这之后也可以使用。但是注释的部分应该和前面的hasChanged存在同样的问题。

\subsubsection{fetch}

fetch就是从server取得数据，然后更新到model中，如果值发生变化的话，就可以发出change事件来更新相应的view

\begin{JavaScript}
    // Fetch the model from the server. If the server's representation of the
    // model differs from its current attributes, they will be overridden,
    // triggering a `"change"` event.
    fetch: function(options) {
      options = options ? _.clone(options) : {};
      if (options.parse === void 0) options.parse = true;
      var model = this;
      var success = options.success;
      options.success = function(resp) {
        if (!model.set(model.parse(resp, options), options)) return false;
        if (success) success(model, resp, options);
        model.trigger('sync', model, resp, options);
      };
      wrapError(this, options);
      return this.sync('read', this, options);
    },
\end{JavaScript}

下面是fetch调用的两个方法。读取成功之后直接将resp解析作为attrs设到model中。而sync访问的restful接口怎么弄的还需要在后面查看Backbone.sync的源码来确定。

\begin{JavaScript}
    // **parse** converts a response into the hash of attributes to be `set` on
    // the model. The default implementation is just to pass the response along.
    parse: function(resp, options) {
      return resp;
    },
\end{JavaScript}

\begin{JavaScript}
    // Proxy `Backbone.sync` by default -- but override this if you need
    // custom syncing semantics for *this* particular model.
    sync: function() {
      return Backbone.sync.apply(this, arguments);
    },
\end{JavaScript}


\subsubsection{save}

save就是将model中的值更新到server上面，我想这里会涉及到model到底是新增数据，还是更新数据吧。如果restful使用不同的Method来实现的话，这里需要好好看看怎么做的。

\begin{JavaScript}
    // Set a hash of model attributes, and sync the model to the server.
    // If the server returns an attributes hash that differs, the model's
    // state will be `set` again.
    save: function(key, val, options) {
      var attrs, method, xhr, attributes = this.attributes;

      // Handle both `"key", value` and `{key: value}` -style arguments.
      if (key == null || typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }

      options = _.extend({validate: true}, options);

      // If we're not waiting and attributes exist, save acts as
      // `set(attr).save(null, opts)` with validation. Otherwise, check if
      // the model will be valid when the attributes, if any, are set.
      if (attrs && !options.wait) {
        if (!this.set(attrs, options)) return false;
      } else {
        if (!this._validate(attrs, options)) return false;
      }

      // Set temporary attributes if `{wait: true}`.
      if (attrs && options.wait) {
        this.attributes = _.extend({}, attributes, attrs);
      }

      // After a successful server-side save, the client is (optionally)
      // updated with the server-side state.
      if (options.parse === void 0) options.parse = true;
      var model = this;
      var success = options.success;
      options.success = function(resp) {
        // Ensure attributes are restored during synchronous saves.
        model.attributes = attributes;
        var serverAttrs = model.parse(resp, options);
        if (options.wait) serverAttrs = _.extend(attrs || {}, serverAttrs);
        if (_.isObject(serverAttrs) && !model.set(serverAttrs, options)) {
          return false;
        }
        if (success) success(model, resp, options);
        model.trigger('sync', model, resp, options);
      };
      wrapError(this, options);

      method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');
      if (method === 'patch') options.attrs = attrs;
      xhr = this.sync(method, this, options);

      // Restore attributes.
      if (attrs && options.wait) this.attributes = attributes;

      return xhr;
    },
\end{JavaScript}

第1行会将this.attributes的值先保存下来以备后面使用

同样是先处理两种情况，key, value。和 {key: value}. 

第15行设定options需要做validation。而且clone了原有的option就是因为下面需要对option做各种操作，会修改option，而且有可能有异步的调用，这样如果不复制的话，就不一定能够保证option是自己想要的。

第20行，options.wait的作用应该是不要这么早就设定model的值。所以分支第23行如果options.wait是true就只做验证。（Pass {wait: true} if you'd like to wait for the server before setting the new attributes on the model.）

第28行，会临时更改this.attributes,因为有备份，所以修改没关系，而且直接修改不会触发各种事件。

我猜第36 ~ 46行是保存到server成功之后回调的函数（等查看sync的时候确认）。 第38行，恢复attributes。 第40行因为wait的情况下attr还没有被设置到model中，所以要merge到server返回的值当中，而且server上的值应该优先级更高，这样才能保证wait和不wait的显示结果一样。第41行表示如果validation失败的话，同样也返回false。然后才真正调用35行备份的option上的success方法。最后trigger module上的sync事件。


第38行和54行都做了一个restore attributes的动作，应该是有同步和异步两种方式来做ajax请求的时候都能保证第一事件恢复原始attributes。

第49 ~ 51行是发送Ajax请求，并且区分到底是新增还是修改操作。

\subsubsection{destroy}

这个方法会删除server上的数据，而且会将model从collection中删除（这个操作是什么时候做的？？是后面的collection中响应这个时间来做的吗），如果他在某个collection中的话。

\begin{JavaScript}
    // Destroy this model on the server if it was already persisted.
    // Optimistically removes the model from its collection, if it has one.
    // If `wait: true` is passed, waits for the server to respond before removal.
    destroy: function(options) {
      options = options ? _.clone(options) : {};
      var model = this;
      var success = options.success;

      var destroy = function() {
        model.trigger('destroy', model, model.collection, options);
      };

      options.success = function(resp) {
        if (options.wait || model.isNew()) destroy();
        if (success) success(model, resp, options);
        if (!model.isNew()) model.trigger('sync', model, resp, options);
      };

      if (this.isNew()) {
        options.success();
        return false;
      }
      wrapError(this, options);

      var xhr = this.sync('delete', this, options);
      if (!options.wait) destroy();
      return xhr;
    },
\end{JavaScript}

同样，先复制option，然后对destory的调用类似于上面对attributes的restore。这里isNew()如果判断是新的对象的话，就不需要做ajax请求来处理。也不需要触发sync事件。


\subsection{Collection}

\begin{JavaScript}
  // Backbone.Collection
  // -------------------

  // If models tend to represent a single row of data, a Backbone Collection is
  // more analagous to a table full of data ... or a small slice or page of that
  // table, or a collection of rows that belong together for a particular reason
  // -- all of the messages in this particular folder, all of the documents
  // belonging to this particular author, and so on. Collections maintain
  // indexes of their models, both in order, and for lookup by `id`.

  // Create a new **Collection**, perhaps to contain a specific type of `model`.
  // If a `comparator` is specified, the Collection will maintain
  // its models in sort order, as they're added and removed.
  var Collection = Backbone.Collection = function(models, options) {
    options || (options = {});
    if (options.model) this.model = options.model;
    if (options.comparator !== void 0) this.comparator = options.comparator;
    this._reset();
    this.initialize.apply(this, arguments);
    if (models) this.reset(models, _.extend({silent: true}, options));
  };

\end{JavaScript}

Model表示的是数据库的一行数据，而Collection表示的则是整个表，或者多行的数据。

Collection创建时的时候可能有一个指定类型的model。...

估计\lstinline$this.initialize.apply(this, arguments);$类似与model的同一个方法，是一个可供自定义的地方，默认实际是一个空方法。

另外有两个reset方法应该是主要的逻辑快。


\begin{JavaScript}[\_reset初始化内部状态]

    // Private method to reset all internal state. Called when the collection
    // is first initialized or reset.
    _reset: function() {
      this.length = 0;
      this.models = [];
      this._byId  = {};
    },

\end{JavaScript}

\begin{JavaScript}[initialize是空方法]
    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},
\end{JavaScript}


\begin{JavaScript}[reset]
    // When you have more items than you want to add or remove individually,
    // you can reset the entire set with a new list of models, without firing
    // any granular `add` or `remove` events. Fires `reset` when finished.
    // Useful for bulk operations and optimizations.
    reset: function(models, options) {
      options || (options = {});
      for (var i = 0, l = this.models.length; i < l; i++) {
        this._removeReference(this.models[i], options);
      }
      options.previousModels = this.models;
      this._reset();
      models = this.add(models, _.extend({silent: true}, options));
      if (!options.silent) this.trigger('reset', this, options);
      return models;
    },

\end{JavaScript}

reset不会触发add和remove事件，但在结束是会触发reset事件。

第7 ~ 9行，使用下面的内部方法移除model对collection的引用，并且移除注册的all事件。
\begin{JavaScript}[移除model对collection的引用，并且remove注册的\_onModelEvent事件]

    // Internal method to sever a model's ties to a collection.
    _removeReference: function(model, options) {
      if (this === model.collection) delete model.collection;
      model.off('all', this._onModelEvent, this);
    },
\end{JavaScript}

第10行设置previous models。

第11行初始化内部状态；

然后将新的models通过add方法添加上去，并且保持silent；

最后如果不需要保持silenc，就触发reset方法。

\subsubsection{set}

类似的，Collection的set也是一个相当复杂的函数，其他很多操作都是基于他的。

\begin{JavaScript}[set]
    // Update a collection by `set`-ing a new list of models, adding new ones,
    // removing models that are no longer present, and merging models that
    // already exist in the collection, as necessary. Similar to **Model#set**,
    // the core operation for updating the data contained by the collection.
    set: function(models, options) {
      options = _.defaults({}, options, setOptions);
      if (options.parse) models = this.parse(models, options);
      var singular = !_.isArray(models);
      models = singular ? (models ? [models] : []) : _.clone(models);
      var i, l, id, model, attrs, existing, sort;
      var at = options.at;
      var targetModel = this.model;
      var sortable = this.comparator && (at == null) && options.sort !== false;
      var sortAttr = _.isString(this.comparator) ? this.comparator : null;
      var toAdd = [], toRemove = [], modelMap = {};
      var add = options.add, merge = options.merge, remove = options.remove;
      var order = !sortable && add && remove ? [] : false;

      // Turn bare objects into model references, and prevent invalid models
      // from being added.
      for (i = 0, l = models.length; i < l; i++) {
        attrs = models[i] || {};
        if (attrs instanceof Model) {
          id = model = attrs;
        } else {
          id = attrs[targetModel.prototype.idAttribute || 'id'];
        }

        // If a duplicate is found, prevent it from being added and
        // optionally merge it into the existing model.
        if (existing = this.get(id)) {
          if (remove) modelMap[existing.cid] = true;
          if (merge) {
            attrs = attrs === model ? model.attributes : attrs;
            if (options.parse) attrs = existing.parse(attrs, options);
            existing.set(attrs, options);
            if (sortable && !sort && existing.hasChanged(sortAttr)) sort = true;
          }
          models[i] = existing;

        // If this is a new, valid model, push it to the `toAdd` list.
        } else if (add) {
          model = models[i] = this._prepareModel(attrs, options);
          if (!model) continue;
          toAdd.push(model);
          this._addReference(model, options);
        }

        // Do not add multiple models with the same `id`.
        model = existing || model;
        if (order && (model.isNew() || !modelMap[model.id])) order.push(model);
        modelMap[model.id] = true;
      }

      // Remove nonexistent models if appropriate.
      if (remove) {
        for (i = 0, l = this.length; i < l; ++i) {
          if (!modelMap[(model = this.models[i]).cid]) toRemove.push(model);
        }
        if (toRemove.length) this.remove(toRemove, options);
      }

      // See if sorting is needed, update `length` and splice in new models.
      if (toAdd.length || (order && order.length)) {
        if (sortable) sort = true;
        this.length += toAdd.length;
        if (at != null) {
          for (i = 0, l = toAdd.length; i < l; i++) {
            this.models.splice(at + i, 0, toAdd[i]);
          }
        } else {
          if (order) this.models.length = 0;
          var orderedModels = order || toAdd;
          for (i = 0, l = orderedModels.length; i < l; i++) {
            this.models.push(orderedModels[i]);
          }
        }
      }

      // Silently sort the collection if appropriate.
      if (sort) this.sort({silent: true});

      // Unless silenced, it's time to fire all appropriate add/sort events.
      if (!options.silent) {
        for (i = 0, l = toAdd.length; i < l; i++) {
          (model = toAdd[i]).trigger('add', model, this, options);
        }
        if (sort || (order && order.length)) this.trigger('sort', this, options);
      }

      // Return the added (or merged) model (or models).
      return singular ? models[0] : models;
    },
\end{JavaScript}

第6 ~ 9行，复制options，将models转变成以个数组。 这里注意第6航初始化了options，使用setOptions对象，
\begin{JavaScript}[如果想覆盖这个行为，那么就在自己提供的options里面包含这些属性好了]

  // Default options for `Collection#set`.
  var setOptions = {add: true, remove: true, merge: true};
\end{JavaScript}

第10 ~ 17行，初始化局部变量；

第22 ~ 27行，如果是Model的实例，取得model，并以model当做id；如果是一系列属性集合，则取得id字段（新的model不是没有id字段吗？？？？）；

第31行，查找model，get方法可以通过很多方式来查找，所以model或者id本身都可以查找到对象（上面好像说的通，如果是属性列表，且没有id字段，那就是一个新的model了。）

第32 ~ 39行，处理已经存在对象的情况；

如果设置了remove，就在modelMap中标记，

如果merge，就取得attrs，bare对象或者model的attrs，再将attrs设定到查询出来的model中；

然后用查询出来的model替换掉数组中的module。

第42行，如果不存在，而且设置了add，就将model添加到toAdd这个list里面。

第43行应该会将bare对象转换为module，通过\lstinline$this._prepareModel$这个方法。

\begin{JavaScript}
    // Prepare a hash of attributes (or other model) to be added to this
    // collection.
    _prepareModel: function(attrs, options) {
      if (attrs instanceof Model) return attrs;
      options = options ? _.clone(options) : {};
      options.collection = this;
      var model = new this.model(attrs, options);
      if (!model.validationError) return model;
      this.trigger('invalid', this, model.validationError, options);
      return false;
    },
\end{JavaScript}

而第46行，\lstinline$this._addReference(model, options)$估计是添加一点引用或者注册事件。

先添加一个\lstinline$_byId$的索引；然后设置对Collection的引用，这是上面\lstinline$this._prepareModel$中如果传入的是model的时候会漏掉的一个操作；最后在model上注册一个all事件的监听。

\begin{JavaScript}
    // Internal method to create a model's ties to a collection.
    _addReference: function(model, options) {
      this._byId[model.cid] = model;
      if (model.id != null) this._byId[model.id] = model;
      if (!model.collection) model.collection = this;
      model.on('all', this._onModelEvent, this);
    },
\end{JavaScript}


第50行，更新一下model这个引用，如果存在就引用查找出来的model。

第51行，第一个order表示要排序，第二个参数\lstinline$model.isNew()$，表示同时也是新的model，所以需要插入到需要排序的队列中，第三个参数，或者\lstinline$!modelMap[model.id]$，表示在modelMap中找不到，（这个是为了处理传入了两个相同的model在列表中的时候，不需要添加两次的意思吗？？？）

最后一步，第52行，将当前model在modelMap中标记。

第58行，遍历一下Collection现在所有的model，如果这个model没有再第32行标记过，就加入到toRemove的列表中，表示传入的model中不包含这个model。

第60行，应该是执行删除操作。

\begin{JavaScript}[如果module存在，清除索引，从数组中删除此对象，调整length]
    // Remove a model, or a list of models from the set.
    remove: function(models, options) {
      var singular = !_.isArray(models);
      models = singular ? [models] : _.clone(models);
      options || (options = {});
      var i, l, index, model;
      for (i = 0, l = models.length; i < l; i++) {
        model = models[i] = this.get(models[i]);
        if (!model) continue;
        delete this._byId[model.id];
        delete this._byId[model.cid];
        index = this.indexOf(model);
        this.models.splice(index, 1);
        this.length--;
        if (!options.silent) {
          options.index = index;
          model.trigger('remove', model, this, options);
        }
        this._removeReference(model, options);
      }
      return singular ? models[0] : models;
    },
\end{JavaScript}

差点看花眼，这里历遍的是传入的model，删除是在Collection做。

第64行开始做add操作。如果存在options.at，就直接将models插入相应的位置。否则，就将（去除重复的）models添加掉list里面。这里在第72行，会将length清0,也就等于是清空数组.

之后触发add和sort事件。


\subsubsection{fetch \& create}

\begin{JavaScript}
    // Fetch the default set of models for this collection, resetting the
    // collection when they arrive. If `reset: true` is passed, the response
    // data will be passed through the `reset` method instead of `set`.
    fetch: function(options) {
      options = options ? _.clone(options) : {};
      if (options.parse === void 0) options.parse = true;
      var success = options.success;
      var collection = this;
      options.success = function(resp) {
        var method = options.reset ? 'reset' : 'set';
        collection[method](resp, options);
        if (success) success(collection, resp, options);
        collection.trigger('sync', collection, resp, options);
      };
      wrapError(this, options);
      return this.sync('read', this, options);
    },

    // Create a new instance of a model in this collection. Add the model to the
    // collection immediately, unless `wait: true` is passed, in which case we
    // wait for the server to agree.
    create: function(model, options) {
      options = options ? _.clone(options) : {};
      if (!(model = this._prepareModel(model, options))) return false;
      if (!options.wait) this.add(model, options);
      var collection = this;
      var success = options.success;
      options.success = function(model, resp) {
        if (options.wait) collection.add(model, options);
        if (success) success(model, resp, options);
      };
      model.save(null, options);
      return model;
    },
\end{JavaScript}


\subsubsection{on model event}

\begin{JavaScript}
    // Internal method called every time a model in the set fires an event.
    // Sets need to update their indexes when models change ids. All other
    // events simply proxy through. "add" and "remove" events that originate
    // in other collections are ignored.
    _onModelEvent: function(event, model, collection, options) {
      if ((event === 'add' || event === 'remove') && collection !== this) return;
      if (event === 'destroy') this.remove(model, options);
      if (model && event === 'change:' + model.idAttribute) {
        delete this._byId[model.previous(model.idAttribute)];
        if (model.id != null) this._byId[model.id] = model;
      }
      this.trigger.apply(this, arguments);
    }
\end{JavaScript}



\subsection{View}

\begin{JavaScript}
  // Backbone.View
  // -------------

  // Backbone Views are almost more convention than they are actual code. A View
  // is simply a JavaScript object that represents a logical chunk of UI in the
  // DOM. This might be a single item, an entire list, a sidebar or panel, or
  // even the surrounding frame which wraps your whole app. Defining a chunk of
  // UI as a **View** allows you to define your DOM events declaratively, without
  // having to worry about render order ... and makes it easy for the view to
  // react to specific changes in the state of your models.

  // Creating a Backbone.View creates its initial element outside of the DOM,
  // if an existing element is not provided...
  var View = Backbone.View = function(options) {
    this.cid = _.uniqueId('view');
    options || (options = {});
    _.extend(this, _.pick(options, viewOptions));
    this._ensureElement();
    this.initialize.apply(this, arguments);
    this.delegateEvents();
  };
\end{JavaScript}

设定好cid，将options的properties都复制到对象本身；

第18行，调用ensureElement，用来创建一个DOM element，保存到el property上。

第19行，然后留一个空的初始化方法。

第20行，delegateEvents，

\begin{JavaScript}[\_ensureElement]
    // Ensure that the View has a DOM element to render into.
    // If `this.el` is a string, pass it through `$()`, take the first
    // matching element, and re-assign it to `el`. Otherwise, create
    // an element from the `id`, `className` and `tagName` properties.
    _ensureElement: function() {
      if (!this.el) {
        var attrs = _.extend({}, _.result(this, 'attributes'));
        if (this.id) attrs.id = _.result(this, 'id');
        if (this.className) attrs['class'] = _.result(this, 'className');
        var $el = Backbone.$('<' + _.result(this, 'tagName') + '>').attr(attrs);
        this.setElement($el, false);
      } else {
        this.setElement(_.result(this, 'el'), false);
      }
    }
\end{JavaScript}

生成DOM元素，分两种情况，有el和没有el。没有的情况通过tagName什么的创建一个元素，带了的话

\begin{JavaScript}
    // Change the view's element (`this.el` property), including event
    // re-delegation.
    setElement: function(element, delegate) {
      if (this.$el) this.undelegateEvents();
      this.$el = element instanceof Backbone.$ ? element : Backbone.$(element);
      this.el = this.$el[0];
      if (delegate !== false) this.delegateEvents();
      return this;
    },
\end{JavaScript}

%$

如果原来已经有元素了的话，需要先undelegateEvents，然后判断是不是jQuery对象，如果不是使用jQuery wrap 一下。

\begin{JavaScript}
    // Set callbacks, where `this.events` is a hash of
    //
    // *{"event selector": "callback"}*
    //
    //     {
    //       'mousedown .title':  'edit',
    //       'click .button':     'save',
    //       'click .open':       function(e) { ... }
    //     }
    //
    // pairs. Callbacks will be bound to the view, with `this` set properly.
    // Uses event delegation for efficiency.
    // Omitting the selector binds the event to `this.el`.
    // This only works for delegate-able events: not `focus`, `blur`, and
    // not `change`, `submit`, and `reset` in Internet Explorer.
    delegateEvents: function(events) {
      if (!(events || (events = _.result(this, 'events')))) return this;
      this.undelegateEvents();
      for (var key in events) {
        var method = events[key];
        if (!_.isFunction(method)) method = this[events[key]];
        if (!method) continue;

        var match = key.match(delegateEventSplitter);
        var eventName = match[1], selector = match[2];
        method = _.bind(method, this);
        eventName += '.delegateEvents' + this.cid;
        if (selector === '') {
          this.$el.on(eventName, method);
        } else {
          this.$el.on(eventName, selector, method);
        }
      }
      return this;
    },
\end{JavaScript}

\begin{JavaScript}
    // Clears all callbacks previously bound to the view with `delegateEvents`.
    // You usually don't need to use this, but may wish to if you have multiple
    // Backbone views attached to the same DOM element.
    undelegateEvents: function() {
      this.$el.off('.delegateEvents' + this.cid);
      return this;
    },
\end{JavaScript}

\subsection{sync}

\begin{JavaScript}
  // Backbone.sync
  // -------------

  // Override this function to change the manner in which Backbone persists
  // models to the server. You will be passed the type of request, and the
  // model in question. By default, makes a RESTful Ajax request
  // to the model's `url()`. Some possible customizations could be:
  //
  // * Use `setTimeout` to batch rapid-fire updates into a single request.
  // * Send up the models as XML instead of JSON.
  // * Persist models via WebSockets instead of Ajax.
  //
  // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests
  // as `POST`, with a `_method` parameter containing the true HTTP method,
  // as well as all requests with the body as `application/x-www-form-urlencoded`
  // instead of `application/json` with the model in a param named `model`.
  // Useful when interfacing with server-side languages like **PHP** that make
  // it difficult to read the body of `PUT` requests.
  Backbone.sync = function(method, model, options) {
    var type = methodMap[method];

    // Default options, unless specified.
    _.defaults(options || (options = {}), {
      emulateHTTP: Backbone.emulateHTTP,
      emulateJSON: Backbone.emulateJSON
    });

    // Default JSON-request options.
    var params = {type: type, dataType: 'json'};

    // Ensure that we have a URL.
    if (!options.url) {
      params.url = _.result(model, 'url') || urlError();
    }

    // Ensure that we have the appropriate request data.
    if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {
      params.contentType = 'application/json';
      params.data = JSON.stringify(options.attrs || model.toJSON(options));
    }

    // For older servers, emulate JSON by encoding the request into an HTML-form.
    if (options.emulateJSON) {
      params.contentType = 'application/x-www-form-urlencoded';
      params.data = params.data ? {model: params.data} : {};
    }

    // For older servers, emulate HTTP by mimicking the HTTP method with `_method`
    // And an `X-HTTP-Method-Override` header.
    if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {
      params.type = 'POST';
      if (options.emulateJSON) params.data._method = type;
      var beforeSend = options.beforeSend;
      options.beforeSend = function(xhr) {
        xhr.setRequestHeader('X-HTTP-Method-Override', type);
        if (beforeSend) return beforeSend.apply(this, arguments);
      };
    }

    // Don't process data on a non-GET request.
    if (params.type !== 'GET' && !options.emulateJSON) {
      params.processData = false;
    }

    // If we're sending a `PATCH` request, and we're in an old Internet Explorer
    // that still has ActiveX enabled by default, override jQuery to use that
    // for XHR instead. Remove this line when jQuery supports `PATCH` on IE8.
    if (params.type === 'PATCH' && noXhrPatch) {
      params.xhr = function() {
        return new ActiveXObject("Microsoft.XMLHTTP");
      };
    }

    // Make the request, allowing the user to override any Ajax options.
    var xhr = options.xhr = Backbone.ajax(_.extend(params, options));
    model.trigger('request', model, xhr, options);
    return xhr;
  };
\end{JavaScript}


第20行，转换method， 对应的为，read对应GET，create对应POST。

\begin{JavaScript}
  // Map from CRUD to HTTP for our default `Backbone.sync` implementation.
  var methodMap = {
    'create': 'POST',
    'update': 'PUT',
    'patch':  'PATCH',
    'delete': 'DELETE',
    'read':   'GET'
  };
\end{JavaScript}

接着设定两个默认参数。

\begin{JavaScript}

  // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option
  // will fake `"PATCH"`, `"PUT"` and `"DELETE"` requests via the `_method` parameter and
  // set a `X-Http-Method-Override` header.
  Backbone.emulateHTTP = false;

  // Turn on `emulateJSON` to support legacy servers that can't deal with direct
  // `application/json` requests ... will encode the body as
  // `application/x-www-form-urlencoded` instead and will send the model in a
  // form param named `model`.
  Backbone.emulateJSON = false;
  
\end{JavaScript}


第29行，设定默认json请求；

第33行，设定请求的url；

第38,39行，设定好数据；

第43 ~ 58行，处理emulateHTTP和emulateJSON；

最后通过Backbone.ajax发送请求

\begin{JavaScript}[通过jQuery发送ajax请求]

  // Set the default implementation of `Backbone.ajax` to proxy through to `$`.
  // Override this if you'd like to use a different library.
  Backbone.ajax = function() {
    return Backbone.$.ajax.apply(Backbone.$, arguments);
  };
\end{JavaScript}

%$


\subsection{Router}

\subsubsection{先知道Router的作用}

\subsubsection{extend}

定义action，在某个匹配的URL fragment匹配时被触发。

\begin{JavaScript}
var Workspace = Backbone.Router.extend({

  routes: {
    "help":                 "help",    // #help
    "search/:query":        "search",  // #search/kiwis
    "search/:query/p:page": "search"   // #search/kiwis/p7
  },

  help: function() {
    ...
  },

  search: function(query, page) {
    ...
  }

});
\end{JavaScript}

\begin{itemize}
\item 避免使用"/"开始router定义;
\item 
\end{itemize}

\begin{JavaScript}
  // Backbone.Router
  // ---------------

  // Routers map faux-URLs to actions, and fire events when routes are
  // matched. Creating a new one sets its `routes` hash, if not set statically.
  var Router = Backbone.Router = function(options) {
    options || (options = {});
    if (options.routes) this.routes = options.routes;
    this._bindRoutes();
    this.initialize.apply(this, arguments);
  };
\end{JavaScript}


主要的逻辑在\lstinline$this._bindRoutes();$


\begin{JavaScript}
    // Bind all defined routes to `Backbone.history`. We have to reverse the
    // order of the routes here to support behavior where the most general
    // routes can be defined at the bottom of the route map.
    _bindRoutes: function() {
      if (!this.routes) return;
      this.routes = _.result(this, 'routes');
      var route, routes = _.keys(this.routes);
      while ((route = routes.pop()) != null) {
        this.route(route, this.routes[route]);
      }
    },
\end{JavaScript}


\subsection{History}