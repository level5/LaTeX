\section{underscore}

返回自己本身的函数，空函数

\begin{JavaScript}
  _.identity = function(value) {
    return value;
  };
  
  _.noop = function(){};
\end{JavaScript}

方法返回传入参数名字为key的property:

\begin{JavaScript}
  _.property = function(key) {
    return function(obj) {
      return obj[key];
    };
  };
\end{JavaScript}

判断对象是否包含指定的key，value对。第8行，此处或后面是用来判断当传入的pair的value是undefined时，obj是否包含key这个property。

\begin{JavaScript}
  _.matches = function(attrs) {
    var pairs = _.pairs(attrs), length = pairs.length;
    return function(obj) {
      if (obj == null) return !length;
      obj = new Object(obj);
      for (var i = 0; i < length; i++) {
        var pair = pairs[i], key = pair[0];
        if (pair[1] !== obj[key] || !(key in obj)) return false;
      }
      return true;
    };
  };
  
  _.has = function(obj, key) {
    return obj != null && hasOwnProperty.call(obj, key);
  }; 
\end{JavaScript}

生成键值对的数组，数组的元素是一个数组，这个数组第一个元素是key,第二个元素是value

\begin{JavaScript}
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };
\end{JavaScript}
\begin{JavaScript}
  var nativeKeys = Object.keys;
  
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    return keys;
  };  
\end{JavaScript}

\begin{JavaScript}
  var createCallback = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      case 2: return function(value, other) {
        return func.call(context, value, other);
      };
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };
\end{JavaScript}

用于将context和function绑定。1,2,3个参数的情况下使用对于当前引擎的最佳性能实现。

void expression 表示undefined。void关键字带一个参数，返回的结果永远是undefined
\begin{JavaScript}
  void 0
  void (0)
  void "hello"
  void (new Date())
//all will return undefined
\end{JavaScript}
使用void 0的好处是：保证结果永远是undefined，因为undefined在JavaScript中不是一个关键字。


\begin{JavaScript}
  _.iteratee = function(value, context, argCount) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return createCallback(value, context, argCount);
    if (_.isObject(value)) return _.matches(value);
    return _.property(value);
  };
\end{JavaScript}

内部使用，对于不同的value返回不同的函数(待补充)

\subsection{Collections Function}
\paragraph{each, forEach}对每个值执行函数。
\begin{JavaScript}
  _.each = _.forEach = function(obj, iteratee, context) {
    if (obj == null) return obj;
    iteratee = createCallback(iteratee, context);
    var i, length = obj.length;
    if (length === +length) {
      for (i = 0; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };
\end{JavaScript}
	
length === +length 判断length是否是数字。

数组就迭代数组，否则迭代所有属性执行callback function。

\paragraph{map, collect}返回一个数组，结果是使用每个值来执行函数的返回值的集合。
\begin{JavaScript}
  _.map = _.collect = function(obj, iteratee, context) {
    if (obj == null) return [];
    iteratee = _.iteratee(iteratee, context);
    var keys = obj.length !== +obj.length && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length),
        currentKey;
    for (var index = 0; index < length; index++) {
      currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };
\end{JavaScript}	

傻了！！！ 上面的代码可以拆分为：

\begin{JavaScript}
  var keys = obj.length !== +obj.length && _.keys(obj); 
  var length = (keys || obj).length;
  var results = Array(length);
  var currentKey;
\end{JavaScript}

\paragraph{reduce} 从集合通过function来生成一个单一的值，如果不提供memo对象，则取集合中的第一个对象作为memo

\begin{JavaScript}
  var reduceError = 'Reduce of empty array with no initial value';
  
  _.reduce = _.foldl = _.inject = function(obj, iteratee, memo, context) {
    if (obj == null) obj = [];
    iteratee = createCallback(iteratee, context, 4);
    var keys = obj.length !== +obj.length && _.keys(obj),
        length = (keys || obj).length,
        index = 0, currentKey;
    if (arguments.length < 3) {
      if (!length) throw new TypeError(reduceError);
      memo = obj[keys ? keys[index++] : index++];
    }
    for (; index < length; index++) {
      currentKey = keys ? keys[index] : index;
      memo = iteratee(memo, obj[currentKey], currentKey, obj);
    }
    return memo;
  };
\end{JavaScript}

第10行，如果memo不存在，而且是个空的集合，报错。

第11行，如果memo不存在，则取集合中的第一个元素作为memo。

回调函数接受4个参数，memo， value， index（key），集合对象。

\paragraph{reduceRight} 前面的reduce是从左往右，这个方法是从右往左。

\begin{JavaScript}
  var reduceError = 'Reduce of empty array with no initial value';	

  _.reduceRight = _.foldr = function(obj, iteratee, memo, context) {
    if (obj == null) obj = [];
    iteratee = createCallback(iteratee, context, 4);
    var keys = obj.length !== + obj.length && _.keys(obj),
        index = (keys || obj).length,
        currentKey;
    if (arguments.length < 3) {
      if (!index) throw new TypeError(reduceError);
      memo = obj[keys ? keys[--index] : --index];
    }
    while (index--) {
      currentKey = keys ? keys[index] : index;
      memo = iteratee(memo, obj[currentKey], currentKey, obj);
    }
    return memo;
  };
\end{JavaScript}

和前一个方法不同就是从后往前迭代。

这里可以看到0转换为boolean型是false。

\paragraph{some} 判断是否有一个测试返回true。

\begin{JavaScript}
  _.some = _.any = function(obj, predicate, context) {
    if (obj == null) return false;
    predicate = _.iteratee(predicate, context);
    var keys = obj.length !== +obj.length && _.keys(obj),
        length = (keys || obj).length,
        index, currentKey;
    for (index = 0; index < length; index++) {
      currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };
\end{JavaScript}

\paragraph{find} 返回第一个满足测试的条件的值

\begin{JavaScript}

  _.find = _.detect = function(obj, predicate, context) {
    var result;
    predicate = _.iteratee(predicate, context);
    _.some(obj, function(value, index, list) {
      if (predicate(value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };
\end{JavaScript}


\paragraph{filter} 返回所有符合测试的值的数组

\begin{JavaScript}
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    if (obj == null) return results;
    predicate = _.iteratee(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };
\end{JavaScript}

\paragraph{reject} 所有测试不通过的值得数组，通过调用filter方法来实现。

\begin{JavaScript}
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };
  
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(_.iteratee(predicate)), context);
  };
\end{JavaScript}

\paragraph{every} 所有测试都通过的时候返回true, 没有什么特别不好理解的。

\begin{JavaScript}
  _.every = _.all = function(obj, predicate, context) {
    if (obj == null) return true;
    predicate = _.iteratee(predicate, context);
    var keys = obj.length !== +obj.length && _.keys(obj),
        length = (keys || obj).length,
        index, currentKey;
    for (index = 0; index < length; index++) {
      currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };
\end{JavaScript}

\paragraph{contains} 也没有啥不好懂的。
 
\begin{JavaScript}
  _.contains = _.include = function(obj, target) {
    if (obj == null) return false;
    if (obj.length !== +obj.length) obj = _.values(obj);
    return _.indexOf(obj, target) >= 0;
  };
\end{JavaScript}

\paragraph{invoke} 调用集合中的每个元素的一个方法（使用参数）

\begin{JavaScript}
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      return (isFunc ? method : value[method]).apply(value, args);
    });
  };
\end{JavaScript}

使用\_.map来调用方法，收集结果。

第2行，将传入的第三个参数起作为参数传给每个方法。

如果method是function，就将每个元素作为上下文来调用这个方法，如果method是方法名，则调用每个元素上的这个方法。

\paragraph{pluck} 用来取得所有元素的某个property的数组。

\begin{JavaScript}
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };
\end{JavaScript}

\_.property方法返回的是一个方法，这个方法会返回传入的对象的名字为key的property的值。


\paragraph{where, findWhere} where是找到所有包含attrs上键值对的item。使用\.filter来过滤，过滤条件是\lstinline!_.matches!； findWhere则是找到第一个满足条件的item

\begin{JavaScript}
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matches(attrs));
  };
  
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matches(attrs));
  };
\end{JavaScript}

\paragraph{max, min}

\begin{JavaScript}
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = obj.length === +obj.length ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value > result) {
          result = value;
        }
      }
    } else {
      iteratee = _.iteratee(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };
\end{JavaScript}

分两种情况处理，如果不存在回调方法，直接查找最大的值就可以了。

如果存在回调方法。则使用回调方法来计算比较的值。

第16行，||后部分是用来处理回调计算结果就是\lstinline!-Infinity!，而且result可能没有被赋值（也可能已经赋值为-Infinity，但这个时候不影响结果）的情况下，给result赋值。


\begin{JavaScript}
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = obj.length === +obj.length ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value < result) {
          result = value;
        }
      }
    } else {
      iteratee = _.iteratee(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };
\end{JavaScript}

和max的情况刚好相反。没有什么需要理解的地方了。

\paragraph{shuffle}洗牌算法,这里是用的是Fisher-Yates shuffle， inside-out方法。

算法大致思路是，有一个原始数组，一个拷贝。连续增大的i，每次去随机数在0~i之间，如果随机数等于i，就将随机数位置的值拷贝到i位置，然后从源数组将值拷贝到随机数的位置。

\begin{JavaScript}
  _.shuffle = function(obj) {
    var set = obj && obj.length === +obj.length ? obj : _.values(obj);
    var length = set.length;
    var shuffled = Array(length);
    for (var index = 0, rand; index < length; index++) {
      rand = _.random(0, index);
      if (rand !== index) shuffled[index] = shuffled[rand];
      shuffled[rand] = set[index];
    }
    return shuffled;
  };
\end{JavaScript}


\paragraph{sample}

