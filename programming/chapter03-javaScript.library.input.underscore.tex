\section{underscore}

\begin{JavaScript}
  _.identity = function(value) {
    return value;
  };
  
  _.has = function(obj, key) {
    return obj != null && hasOwnProperty.call(obj, key);
  }; 
  
\end{JavaScript}

\begin{JavaScript}
  var nativeKeys = Object.keys;
  
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    return keys;
  };  
\end{JavaScript}

\begin{JavaScript}
  var createCallback = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      case 2: return function(value, other) {
        return func.call(context, value, other);
      };
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };
\end{JavaScript}

用于将context和function绑定。1,2,3个参数的情况下使用对于当前引擎的最佳性能实现。

void expression 表示undefined。void关键字带一个参数，返回的结果永远是undefined
\begin{JavaScript}
  void 0
  void (0)
  void "hello"
  void (new Date())
//all will return undefined
\end{JavaScript}
使用void 0的好处是：保证结果永远是undefined，因为undefined在JavaScript中不是一个关键字。


\begin{JavaScript}
  _.iteratee = function(value, context, argCount) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return createCallback(value, context, argCount);
    if (_.isObject(value)) return _.matches(value);
    return _.property(value);
  };
\end{JavaScript}

内部使用，对于不同的value返回不同的函数(待补充)

\subsection{Collections Function}
\paragraph{each, forEach}对每个值执行函数。
\begin{JavaScript}
  _.each = _.forEach = function(obj, iteratee, context) {
    if (obj == null) return obj;
    iteratee = createCallback(iteratee, context);
    var i, length = obj.length;
    if (length === +length) {
      for (i = 0; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };
\end{JavaScript}
	
length === +length 判断length是否是数字。

数组就迭代数组，否则迭代所有属性执行callback function。

\paragraph{map, collect}返回一个数组，结果是使用每个值来执行函数的返回值的集合。
\begin{JavaScript}
  _.map = _.collect = function(obj, iteratee, context) {
    if (obj == null) return [];
    iteratee = _.iteratee(iteratee, context);
    var keys = obj.length !== +obj.length && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length),
        currentKey;
    for (var index = 0; index < length; index++) {
      currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };
\end{JavaScript}	

傻了！！！ 上面的代码可以拆分为：

\begin{JavaScript}
  var keys = obj.length !== +obj.length && _.keys(obj); 
  length = (keys || obj).length;
  results = Array(length);
  var currentKey;
\end{JavaScript}




