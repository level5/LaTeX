\chapter{Shell Commands}

\section{基本知识}

\subsection{执行}

\begin{Command-Line}[开头告诉shell使用什么bash]
#！/bin/bash
\end{Command-Line}


执行脚本：

\begin{itemize}
\item 脚本作为参数的方式
\begin{Command-Line}
bash script.sh   #脚本位于工作目录（当前目录）
\end{Command-Line}

\item 修改脚本成可执行文件

\begin{Command-Line}[内核会读取首行来确定执行的bash]
chmod a+x script.sh
./script.sh
\end{Command-Line}

\end{itemize}

\subsection{变量}

变量名就是一个他引用的value的占位符。需要区分变量名，和变量名引用的值。如果variable1是变量名的话。\$variable1是变量名引用的值

变量不需要使用前置\$的场景：
\begin{itemize}
\item 声明和赋值的时候；
\item \lstinline$unset$和\lstinline$export$的时候；
\item 数学表达式((...))
\item loop的头中
\item ...
\end{itemize}


\subsubsection{对变量求值}



\subsubsection{参数}

\begin{itemize}
\item \$0, \$1, \$2, ... \${10}, \${11}, etc!,对应位置的参数，\$0表示的是命令名，参数是从\$1开始。
\item \$\#参数个数。
\item \$* 所有参数，但是是当做一个参数
\item \$@ 所有参数，但是是当做分开的参数
\item \lstinline$shift$ 是的所有参数都往前移动一位，\$1被丢弃。
\end{itemize}

\begin{Command-Line}[\$*和\$@的区别]
x
x
x
\end{Command-Line}

\subsection{String}

\subsection{exit和exit的状态}

可以使用\$?来取得最后执行的命令的exit status的值，0表示success。


在函数中，可以使用return来返回exit status。如果没有返回，则最后执行的一条语句的exit status就是函数的exit status。

\subsection{测试}

\subsubsection{if, else}

对于ifelse,其实就是判断条件的exit status来看执行哪个分支，0表示真，1表示false，因为在Unix中，0状态码表示success。

\subsubsection{test}

\lstinline$test$， \lstinline$[$

test的参数被当做comparison expression或者file test。根据比较结果来返回exit status，0为true，1为false。

\lstinline$[$是built-in命令；

\lstinline$test expr$

\lstinline$[expr]$

\begin{itemize}
\item !expr
\item (expr)
\item expr1 -a expr2
\item expr1 -o expr2 
\end{itemize}

expr计算结果按下面的规则根据参数的个数来返回结果
\begin{itemize}
\item 0 argument，结果是false
\item 1 argument，当argument不为null的时候，结果是true
\item 2 arguments

当第一个参数是！，之后当第二个参数是null的时候结果才为true

\begin{Command-Line}

上面的实例

\end{Command-Line}

当地一个参数是unary操作符，结果就是unary操作的结果；如果第一个参数是个非法的unary，则结果是false。


\item 3 arguments 

如果第二个参数是binary操作符，结果就是将第一个参数和第三个参数做为操作数，binary的结果。

如果第一个参数是！，那么结果就是将第二个和第三个参数按上面的描述执行

如果第一个参数是（，第三个参数是），则第二个参数按照一个参数执行方式执行，结果就是他。

否则，表达式结果是false。

\item 4 arguments

如果第一个是！，后面三个就按照三个参数的方式计算，否则按优先级使用上面的规则

\item 5 arguments

按优先级使用上面的规则

\end{itemize} 


File test Operators

\begin{itemize}
\item -e， -a file exist, 判断文件是否存在，-a已经不推荐使用。
\item -a

\item -s file is not zero size.

\item -f
\item -d
\item -b
\item -c
\item -p
\item -h
\item -L
\item -S
\item -t

\item -r
\item -w
\item -x

\item -g
\item -u
\item -k

\item -O you are owner of file.
\item -G group-id of file same as yours.
\item -N file modified since it was last read.

\item f1 -nt f2 
\item f1 -ot f2
\item f1 -ef f2

\item !
\end{itemize}


Integer comparison
\begin{itemize}
\item -eq
\item -ne
\item -gt
\item -ge
\item -lt
\item -le
\end{itemize}

String comparison
\begin{itemize}
\item =
\item ==
\item !=

\item \lstinline$\<$
\item \lstinline$\>$

\item -z is null
\item -n is not null
\end{itemize}

\lstinline$[$和\lstinline$[[$中=和==不同的场景

test有\lstinline$[$和\lstinline$[[$

\subsubsection{let \& ((...))}

((...)) and let construct return an exit status, according to whether the arithmetic expressions they evaluate expand to a non-zero value.

\begin{Command-Line}
[root@192 tmp]# ((0 && 1))
[root@192 tmp]# echo $?
1
[root@192 tmp]# let "num = ((0 && 1))"
[root@192 tmp]# echo $num
0
[root@192 tmp]# let "num = ((0 && 1))"
[root@192 tmp]# echo $?
1
[root@192 tmp]# ((200 || 11))
[root@192 tmp]# echo $?
0
[root@192 tmp]# let "num = ((200 && 1))"
[root@192 tmp]# echo $num
1
[root@192 tmp]# let "num = ((200 && 1))"
[root@192 tmp]# echo $?
0
\end{Command-Line}

这里结果都很明确，搞清楚数学表达式的值和let及\lstinline$((...))$exit status的关系就可以了。

数学表达式的值非零的话，let和\lstinline$((...))$的exit status就是0，数学表达式的值为零的时候，exit status就为1.

然后就是在各种语言中\lstinline$num=2+1$的值就是num的值3，比如说c语言中经常出现的语句\lstinline$if((c=getchar()) != EOF){...}$


\lstinline$((...))$的Integer Comparison
\begin{itemize}
\item <
\item <=
\item >
\item >=
\end{itemize}


\subsection{运算符}


