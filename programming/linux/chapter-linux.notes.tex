\chapter{Notes}

\section{每天一条命令}
命令列表：
dd, find, grep, wc, iptables, \$((...)) , head， gzip, wc

curl



\subsection{find}

find列出指定目录及其子目录的文件和文件夹

\begin{Bash}[查找当前目录及子目录的文件和文件夹]
find .
\end{Bash}


\subsubsection{-print, -print0}
\lstinline$-print$, 打印出查找到的文件和文件夹，'\\n'作为文件名的间隔。默认情况下不输入-print也会打印出文件夹和文件名。

但是'\\n'是文件名的合法字符，所以这样可能导致错误的文件名。这个时候可以使用\lstinline$-print0$,这个时候改用'\\0'作为间隔。

\subsubsection{-name, -iname}

\lstinline$-name$指定了文件名必须匹配的字符串，可以含有通配符。\lstinline$-iname$作用和\lstinline$-name$一样，但是不区分大小写。

\begin{Bash}[名字匹配指定的字符串]

find . -name 'Lib'

find . -iname 'LIB'

\end{Bash}


\subsubsection{ -path, -regex, -iregex}


而\lstinline$-path$则是匹配路径（包含文件名）是否匹配给定字符串, \lstinline$-regex$和\lstinline$-path$类似，不过是基于正则表达式来匹配路径的。

这部分需要加强，已将《学习正则表达式》加入日程之中。


\subsubsection{否定参数 ！}

\begin{Bash}[名字不以.txt结尾的文件]

find . ! -name "*.txt"

\end{Bash}


\subsubsection{基于深度查询 -maxdepth, -mindepth}

\begin{Bash}[查找第二层目录的所有文件]

find . -maxdepth 2 -mindepth 2

\end{Bash}

\begin{Bash}[深度为0的文件就是查找的目录]

find . -maxdepth 0

find /root -maxdepth 0

\end{Bash}

\subsubsection{-type 文件类型}

\begin{Bash}

find . -type f 

find . -type d

\end{Bash}


% 这里使用表格， 今天回家搞定

文件		f

目录		d

符号链接	l

...


\subsubsection{按文件时间}


\begin{itemize}
\item 访问时间 -atime(access time) 最近一次访问时间
\item 修改时间 -mtime(modify time) 文件内容最后一次修改时间
\item 变化时间 -ctime(change time) 文件元数据(权限或者所有权)最后一次改变时间
\end{itemize}


\begin{Bash}[单位是天， 当前为0]

find . -atime -7  # 最近7天访问过的

find . -atime 7	  # 刚好7天前访问过

find . -atime +7  # 访问时间超过7天

\end{Bash}


\subsubsection{-size 基于文件大小}


\begin{Bash}

find . -type f -size +2k 		# 大于2KB的文件

find . -type f -size 2k			# 等于2KB的文件

find . -type f -size -2k		# 小于2KB的文件
\end{Bash}


\subsubsection{-perm 权限}

\subsubsection{-delete}

\begin{Bash}[删除匹配的文件]

find . -type f -perm 644 -delete


\end{Bash}

\subsubsection{-exec 将查找的文件当做输入执行命令}

\subsubsection{多个条件}

\subsubsection{跳过特定目录}

\begin{Bash}[]

find devel/source_path \( -name ".git" -prune \) -o \( -type -f -print \)

\end{Bash}

\subsubsection{结合xargs}

\paragraph{xgrgs的使用}

什么命令都不带时，默认使用的是\lstinline$\bin\echo$.

-d, 输入的截断符号

\begin{Bash}[第一次后面有空行是因为截断符是：，所以最后的换行得到了保留]

[root@192 Development]# echo "args1:args2" | xargs -d :
args1 args2

[root@192 Development]# echo -n "args1:args2" | xargs -d :
args1 args2
[root@192 Development]# 

\end{Bash}

而 -0 则表示使用\lstinline$\0$来截断输入。这样可以配合find命令的\lstinline$-print0$来使用，可以在文件名中有换行的情况下安全使用。


-n, 如果参数超出指定的数量，则每次最多使用多少个参数来多次执行命令。如果-x也只指定了，那么如果参数超出就会退出了。


\subsection{解压命令 tar}

\begin{Bash}
tar -xzvf xx.tar.gz # -z解压tar.gz

tar -xjvf xx.tar.bz2 # -j解压tar.bz2

# -v 打印处理过程
# -x 解压
# -f 不知道
\end{Bash}


%gzip这条命令也看看吧。


\subsection{创建链接命令 ln}

\begin{Bash}
ln -s item link # 创建symbol link， 如果item是相对位置，则是相对于link的位置。
ln file link # 默认创建硬链接
\end{Bash}


符号链接类似于windows的快捷方式；


硬链接应该就是一个真正指向文件的链接。只有所有的硬链接都删除，文件才会被删除。等书拿出来之后补充。

\begin{Bash}

\end{Bash}

\subsection{判断当前脚本是否是以root用户来执行}


\$(..)看做`..`的另外一种形式。将一条或多条命令的output重新分配。



\begin{Bash}[old way]
#!/bin/bash
# Init
FILE="/tmp/out.$$"
GREP="/bin/grep"
#....
# Make sure only root can run our script
if [ "$(id -u)" != "0" ]; then
   echo "This script must be run as root" 1>&2
   exit 1
fi
# ...
\end{Bash}


\begin{Bash}[new way]
#!/bin/bash
# Init
FILE="/tmp/out.$$"
GREP="/bin/grep"
#....
# Make sure only root can run our script
if [[ $EUID -ne 0 ]]; then
   echo "This script must be run as root" 1>&2
   exit 1
fi
# ...
\end{Bash}

\subsection{收集进程资料}



常用的几条命令，ps，top, pgrep.

\subsubsection{ps}

ps不带任何参数，收集当前终端相关的进程。

\begin{itemize}

\item -f， full，包含更多列信息。

\item -e, every，系统上运行的所有信息，-ax（all）也可以达到同样效果。

%查一下a和x的含义

\item -o,指定想显示的列，用逗号作为限定符，分隔的参数之间没有空格。

\begin{itemize}
\item pcpu
\item pid
\item ppid
\item pmem
\item com, 可执行文件名
\item cmd
\item user
\item nice, 优先级
\item time, 累计CPU时间
\item etime, 启动后流逝的时间
\item tty
\item euid,有效用户ID
\item stat, 进程状态
\end{itemize}

参数后面加上=号，表示移除列名，不是说移除这一列。

% -o使用的过滤器是什么？查一下。

% u呢，是什么啊？

% -f呢？

% ps aux 是怎么说？？

\item --sort，对命令进行排序，格式是

\begin{Bash}[参数前的+-表示升序或者降序]
ps [OPTIONS] --sort -parameter1,+parameter2,parameter3
\end{Bash}


\item -C,这里是大写C，指定命令名称.这里是要全称，如果使用pgrep就会好一些，只需要一部分名称就可以了。

%是要全称吗？？如果是要全称，那这个不太好用啊。 pgrep是否更好用

\item -t，指定终端

\item -L，线程相关，这里先不关心了。

\item 原来f，u，w是一些制定好输出格式的选项。





\end{itemize}

\subsubsection{pgrep}

-d,指定定界符

-u，指定用户（拥有者）列表

-u和-U，小写是有效用户，大写是真实用户

%最后还是提醒我需要查看用户这部分的知识啊。



\subsubsection{top}

top

\subsubsection{which, whereis, file, whatis}

\paragraph{which} 找出某个命令的位置

\paragraph{whereis} 和which类似，但不仅返回命令的路径，还能够打印出其对应的命令手册的位置以及命令源代码的路径。

\paragraph{file} 可以用来确定文件的类型，这条命令会打印出该文件类型相关的细节信息。



\subsection{杀死进程及发送或者相应信号}

kill可以用来发送信号，trap用来处理所接受的信号

%这部分作为明天的内容算了，睡觉。

\subsection{curl命令}


\section{shell中我感到疑惑或者不知道的东西}


\subsection{subprocess Vs. subshell}


\section{我记不太清楚的操作符}


\subsection{(...)}

\subsubsection{命令组}

命令组，会启动一个子shell(subsehll).

\subsubsection{数组初始化}


